<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018总结]]></title>
    <url>%2F2019%2F01%2F24%2F2018%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2019%2F01%2F06%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[操作系统基础知识为了更好地掌控计算机，使其更加有序的工作，于是出现了操作系统。操作系统是掌控计算机上所有事情的系统软件，其需要完成下面五种功能：1、控制和管理计算机系统的的所有硬件和软件资源。2、合理的组织计算机的工作流程，保证计算机资源的公平竞争和使用。3、方便用户使用计算机。4、防止对计算机资源的非法侵占和使用。5、保证操作系统自身的正常运转。操作系统的设计目标：方便性、有效性、可扩展性、开放性、可靠性、可移植性从微观来看，在任意时刻，计算机内只有一个进程在运行。在只有一个CPU的情况下，这些进程就是交替运行的。用户态和内核态：运行于内核态的程序可以访问的资源多，但可靠性、安全性要求高，维护管理比较复杂；用户态程序可以访问的资源有限，但可靠性、安全性要求较低，编写程序和维护管理都比较简单。应该在内核态实现的功能：CPU和内存的管理必须在内核态下实现。诊断与测试程序也应该在内核态下实现，因为诊断和测试需要访问计算机的所有资源，否则无法判断计算机是否正常工作。IO管理也一样，因为要访问各种设备和底层数据结构，所以也必须在内核态下实现。对于文件管理可以一部分放在用户态一部分放在内核态。文件系统本身的管理必须放在内核态下，否则任何人都有可能破坏文件系统的结构；用户文件的管理可放在用户态下，另外：用户程序、编译程序、编辑程序、网络管理的部分功能等可以放在用户态下执行。实现操作系统安全性的基本技术：身份鉴别、存取控制、最小特权管理、硬件保护、安全审计、入侵检测、数据加密存取控制：当主体访问一个客体时，操作系统根据该客体的存取控制表检查该主体是否有相应的访问权限。最小特权管理：每个主体只能拥有与其操作相符的必要最小特权集，不能赋予用户、进程超越其执行任务所必须特权之外的任何其他特权。硬件保护：采用硬件方式对内存和进程运行进行保护。CPU:运算器、控制器、寄存器、高速缓存运算器：负责指令中的算数和逻辑运算，由算数逻辑单元(ALU)、累加寄存器、数据缓冲寄存器和条件寄存器等组成，运算器是计算机计算的核心。寄存器：是CPU内部指令处理过程中暂存数据、地址以及指令信息的存储设备，在计算机的存储系统中它具有最快的访问速度。高速缓存：处于CPU和物理内存之间，一般由控制器中的内存单元来管理，它的访问数据快于内存但是低于寄存器。利用程序执行的局部性原理使得高速的指令处理和低速的内存访问得以匹配，从而提高了CPU的利用率。 处理器管理程序的顺序执行：程序的顺序执行具有以下三个特点：1、顺序性。当程序在CPU上执行时，CPU按程序规定的顺序严格的执行程序的操作，每个操作都必须在前一个操作结束后才能开始。除人为的干预造成计算机暂时停顿外，前一个操作的结束就意味着后一个操作的开始。程序和计算机执行程序的活动严格一一对应。2、封闭性。程序运行时独占全机资源，程序运行的结果仅由初始条件和程序本身的操作决定，程序一旦开始，其运行结果不会受到外界因素的影响。也就是说，程序是在完全封闭的环境下运行的。3、可再现性。程序运行的结果仅与初始条件有关，而与运行的时间和速度无关。只要初始条件相同，当程序重复运行时，无论是从头至尾不间断运行还是断断续续的运行，都将获得相同的结果。缺点：CPU与外部设备之间不能并行工作，资源利用率低，计算机系统效率不高。程序的并发执行：在计算机硬件引入通道和中断结构后，就使得CPU与外部设备之间以及外部设备与外部设备之间可以并行操作，使得多道程序设计成为可能。对于单个CPU而言，同一时刻，只有一个进程在运行，多个进程交替运行。程序的并发实质上是程序将的并发，CPU与IO设备之间的并行。并发程序对资源的共享与竞争，又会导致程序执行环境与运行速度的改变，从而可能产生程序运行结果不唯一的问题。特点：间断性、失去了封闭性、不可再现性(由于失去了封闭性，必然失去了不可再现性，没有了封闭性，其运行结果可能被外部环境所干扰，故其每次的运行结果可能都不是唯一的，故不可再现)进程：进程是一个可并发执行的、具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和调度的基本单位。进程实体=程序段+相关数据段+PCB进程有以下五个特点：1、 动态性 ，进程的实质是程序的一次执行，既然是一次执行，就表明其有生命周期，具有”创建-运行-消亡“的过程。2、并发性 ，多个进程实体在同一时间内能够并发执行，引入进程的目的也正是为了使内存中的多个程序能够在执行时间上重叠，以提高系统资源的利用率。3、独立性 ，每个进程都是一个独立运行的基本单位，也是系统进行资源分配和调度的基本单位4、异步性 ，各进程按各自独立的、不可预知的速度向前推进。进程具有”执行-暂停-执行“这种间断性活动规律。5、结构性 ，系统为每个进程都配置了一个PCB，从结构上看，每个进程都由：程序段、数据段以及PCB这三部分组成。 进程的状态及转换：两状态进程模型：运行和非运行进程的三态模型：运行-就绪-阻塞就绪-&gt;运行-&gt;阻塞-&gt;就绪 &amp;&amp;运行-&gt;就绪 就绪不能直接转为阻塞，阻塞也不能直接转为运行。运行：进程获得了CPU和其他所需要的资源，目前正处于运行的状态。阻塞：进程运行中发生了某种等待事件(如发生了IO等待操作)而暂时不能运行的状态，处于该状态的进程不能去竞争CPU，因为此时尽管把CPU分配给该进程，其也无法运行，处于阻塞状态的进程可以有多个。就绪：进程获得了除CPU之外的所需资源，一旦得到CPU就可以立即投入运行。不能运行的原因还是因为CPU的资源太少，智能等待分配CPU资源，在系统中处于就绪状态的进程可能有多个，通常是将它们组成一个进程队列。虽然进程有三个基本状态，但对于每个进程而言，其生命周期内不一定都要经历这三个状态，对于一些计算性的简单进程，运行很短的时间就结束了，也就无须进入阻塞状态，所以个别进程可以不经历阻塞状态。 进程的五态模型：1、进程的产生2、进程的终止3、进程的 进程的挂起：新创建的进程一旦被系统接纳就会一直存在于内存中，直到被终止。在这种情况下，一方面随着系统中进程数量的不断增多，系统内存资源会变得越来越紧张；另一方面，由于CPU的速度远远高于I/O的速度，这使得内存中经常出现大部分进程都在等待I/O操作而CPU却空闲的现象。当内存中没有就绪进程时，为了减少CPU的空闲时间，可以采用交换技术将内存中暂时不能运行的某些进程挂起，释放其占用的内存资源，以便重新接纳一个新进程或外存上已经具备运行条件的进程进入内存的进程就绪队列。进程挂起(或者称换出)是指内存中的进程被暂时移出保存到外存中(如磁盘)的过程。当某个进程被挂起时，若被挂起的进程处于运行状态则停止执行。引起挂起的原因大致有一下三种：1、用户的请求。如果用户发现运行程序中有错误，为了调试、检查和修改程序或数据，用户可能会挂起相应的进程。2、父进程的请求。有时父进程希望挂起某个子进程，以便进行某种检查和修改，或协调不同子进程之间的行为。如在程序调试中挂起某些进程。3、操作系统的原因。操作系统引起的挂起情况可分为以下三种。(1)交换：当操作系统发现系统的内存资源已经不能满足运行进程的需要时，可以将当前不重要的进程挂起，以达到平衡系统负载的目的。(2)出现问题或者故障时，当系统出现故障时，操作系统会暂时将系统中涉及该故障的进程挂起，等故障恢复后，再将这些进程恢复到挂起前的状态(换入，由外村调入内存)(3)操作系统的需要。为监视系统的活动，操作系统可以挂起和激活一些系统资源使用状况的进程和用户进程活动的记账进程。 由于CPU在任一时刻只能执行一条指令，因此任意时刻在CPU上执行的进程只有一个，其执行哪一个进程的哪条指令是由程序计数器指定的。也就是说：在物理层面上所有进程公用一个程序计数器。PCB：进程控制块；是操作系统中最重要的数据结构之一。因为它是进程存在的唯一标志，PCB中存放着操作系统所需的用于描述进程当前情况的全部描述信息，以及控制进程运行的全部控制信息和相关的资源信息。在几乎所有的多道程序操作系统中，进程的PCB都是全部或部分常驻内存，操作系统通过PCB感知进程的存在，并且根据PCB对进程实施控制和管理。大多数的PCB中都包含：1、进程标识符，每个进程都必须有唯一的进程标识符；2、进程的当前状态，它表明进程的当前状态，并作为进程调度程序分配CPU的依据，仅当进程处于就绪状态时才可以被调度执行。若进程处于阻塞状态，还需要在PCB中记录阻塞的原因，以供唤醒原语唤醒进程时使用。3、进程中的程序段与数据段地址。用于将PCB和与之对应的进程在内存或外存的程序段和数据段联系起来。4、进程资源清单。列出进程所拥有的除CPU之外的资源记录，如打开的文件列表和拥有的IO设备等。5、进程优先级6、CPU现场保护区。7、进程同步与通信机制。用户实现进程间互斥、同步、和通信所需的信号量、信箱、或消息队列的指针等。8、PCB队列指针或链接字。用于将处于同一个状态的进程链接成一个队列。9、与进程相关的其他信息。如进程的家族信息、进程的所属用户、进程占用CPU的时间以及进程记账信息等。 进程块的组织方式：(目前常用的有以下三种)1、线性表方式2、链接表方式，将PCB链接成队列，从而形成进程就绪队列、进程阻塞队列、进程运行队列等。优点：可以很方便的对同类PCB进行管理，操作简单。缺点：查找某个进程的PCB就比较麻烦，因此只适用于小系统中进程数比较少的情况。3、索引表方式，系统按照进程的状态分别建立就绪索引表、运行索引表、阻塞索引表等，通过索引表来管理系统中的进程，索引表可以很方便的查找到某个进程的PCB，因此适用于进程数比较多的情况，但是索引表需要占用一定的内存空间。 p60 持续更新中……]]></content>
      <categories>
        <category>考研复试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据通信]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[服务器群(server farm ) - - - &gt;广域网：采用的交换技术有：电路交换、分组交换、ATM、帧中继电路交换：在两个站点之间建立一条专用的途径多个网络节点的通信路径。这一路径是由连接结点与结点的一连串物理链路构成的。每段物理链路都会为这一连接建立一条专用的逻辑通道。由源点产生的数据沿着这条专用通道被尽可能的快速传送。对每个结点来说，接收到的数据无延迟地通过路由选择或交换到达适当的出口通道。—&gt;最常见的就是电话网。特点：独占性、实时性、线路的利用率不高分组交换：其没有必要建立一条独占传输能力的贯通网络的专用通道。相反，数据是以一连串的小块的形式发送出去的，这些小的数据块就被称为分组。每个分组都将沿着从源点到终点的路径，途中经过一个个的结点，穿越整个的结点，穿越整个网络。对于每个结点来说，他接受完整的分组，先将其暂存，然后再传送给下一个结点。分组交换网常用于从终端到计算机和从计算机到计算机之间的通信。（分组可以不有序到达，常用于常用于终端—计算机之间的通信或者计算机—计算机通信）特点：线路利用率不高，尽力而为、不保证服务质量ATM（异步传输方式）是电路交换和分组交换领域共同发展的结晶。ATM使用的是长度固定的分组，称为信元。其几乎不为差错控制提供额外开销，而依赖传输系统自身的稳定性以及终端系统的高层逻辑来捕获和纠正错误。由于使用了固定长度的分组，ATM需要处理的额外开销比帧中继还要少。其吸收了电路交换的特点，面向连接；采用了异步时分复用技术，线路利用率高。局域网：总线型、星型、环型 协议体系结构OSI： 物理层、数据链路层、网络层、传输层、会话层、表示成、应用层一个较为简单的对应关系：应用层：为网络应用提供服务 DNS/SMTP/FTP/SSH/HTTP表示层：数据表示会话层：在用户间建立会话关系传输层：不同主机进程间的通信 TCP/UDP网络层：在主机之间传输分组 ICMP/OSPF/RSVP/ARP数据链路层：在节点间可靠地传输帧物理层：位流的透明传输 双绞线、光纤、卫星、地面微波TCP/IP：物理层、数据链路层、网络层、传输层、应用层 UDP:通过最少的协议机制发送报文，不保证交付的正确性、不维护到达时的顺序性，不管是否重复到达主机的每一个进程都有一个唯一的端口号，接收到的信息，根据端口号传送到特定的client中。 分层的优点：1、采用结构化的方法，可以把错综复杂的问题分解成较简单的问题，易于处理。2、各层分工明确、职责清晰。3、各层相对独立，一层细节的改变对其它层没有影响。 套接字(SOCKET)- - -&gt;源端口、目的端口、协议 (port , protocol)]]></content>
      <categories>
        <category>考研复试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Worlds]]></title>
    <url>%2F2018%2F12%2F26%2FWorlds%2F</url>
    <content type="text"><![CDATA[序号 名称 链接 时间 成就 1 … world list1 2018.12.26 2 … world list2 2018.12.27]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[考研政治]]></title>
    <url>%2F2018%2F11%2F23%2F%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[徐涛老师的30天背诵计划&lt;iframe height=”600”src=”https://www.ximalaya.com/thirdparty/player/album/player.html?id=18947222&amp;type=red&quot; frameborder=0 allowfullscreen&gt;]]></content>
      <categories>
        <category>政治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[专业课笔记]]></title>
    <url>%2F2018%2F11%2F02%2F%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[结构体之间可以互相整体赋值，即可以把一个结构体整体赋值给另一个结构体。某二叉树的先序遍历和后序遍历序列正好相反，则该二叉树一定是:每层都只有一个子节点的树、只有一个叶子结点、高度等于其结点数的二叉树。自增和自减运算符，只能用于变量，不能用于常量和表达式。例如5++，–(a+b)等都是非法的。也可用在指针变量中，使指针向上或向下一个地址。 若某无向图一共有16条边，并且有3个度为4的顶点，4个度为3的顶点，其余顶点的度均小于3，则该无向图至少有多少个顶点？无向图16条边，每条边有两个度，所以总度数为3232-34-43=8剩余节点度均小于3，则最大为2 8/2=43+4+4=11所谓m阶B-树中的m是指：每个分支结点至多有m颗子树。在顺序表中查找元素，可以使用：顺序查找，在顺序表元素已经排好序的情况下，可以使用折半查找。 折半查找的条件：折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 B-树中m的意思是：所有结点孩子结点个数的最大值 静态链表中指针指示的是：链表中下一元素在数组中的地址。 pursuing postgraduate study67 折半查找有序表(6,15,30,37,65,68,70,72,89,99),若查找元素37,需依次与表中元素( D )进行比较,。 A.65,15,37 B.68,30,37 C.65,15,30 D.65,15,30,37 折半查找： int mid=(low+high)/2; if (key==a[mid]) { return mid; } else if (key&gt;a[mid]) { low=mid+1; } else if (key&lt;a[mid]) { high=mid-1; } } 哈夫曼树的特点：1、权值越大的叶结点离根结点越近，权值越小的叶节点离根节点越远（这样的二叉树WPL最小）WPL=路径长度*该路径叶结点的权值之和。2、无度为1的结点。3、哈夫曼树不是唯一的。 完全二叉树、满二叉树、二叉排序树、线索二叉树中与存储结构有关的是：线索二叉树。 递归的优缺点：1、问题的数学模型或算法的设计方法本来就是递归的，采用递归算法来描述其结构非常自然。2、算法的描述直观，结构清晰，简洁；算法的正确性验证比非递归容易。 缺点：1、执行时间和空间开销往往比非递归大，当问题规模较大时尤为明显。2、对算法的优化比较困难3、分析和跟踪算法的执行过程比较麻烦4、当描述算法的语法不具有递归功能时，算法无法描述 解决散列冲突的三种方法：1、开放地址法优点：问题规模较小时节省存储空间，二次探测法可以避免出现聚集现象。缺点：为了减少散列冲突，要求装填因子a较小，当问题规模较大时，浪费存储空间。线性探测容易差生”聚集“，而二次探测法不容易探测到整个散列空间。删除元素不能简单的将被删除的元素的存储空间置为空，只能在删除元素上做删除标记，不是真正意义的删除元素，否则截断在它之后进入散列表同义词的查找路径。 2、再散列法优点：不容易产生”聚集“现象缺点：需要准备多个散列函数（构造一个好的散列函数并非轻而易举的事，更何况构造多个），增加了计算时间。 3、链地址法优点：1、链地址法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；2、由于链地址法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；3、开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而链地址法中可取α≥1，且结点较大时，链地址法中增加的指针域可忽略不计，因此节省空间；4、在用链地址法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。缺点： （需要占据一定的空间）指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。 C语言计算时按照：int 2；short 2；long 4；float 4；double 8；unsigned 2；unsigned 2；long 4； scanf()的输入结束标志：1、遇到空格、回车、tab。2、按指定的宽度结束，如”%3d“，只取3列。3、遇非法输入。gets getchar可以有空格。 break和continuebreak只能用于循环语句和switch语句，从循环体内跳出循环。continue结束本次循环，跳过循环体中下面尚未执行的语句，接着进行下一次是否执行循环的判定。 含有n个结点的二叉排序树，其中序遍历序列都是一样的，前序遍历序列不同则对应了不同形状的二叉排序树，不同形态的个数可以用catalan函数表示。 有如下函数调用语句：func(rec1, rec2+rec3, (rec4, rec5));该函数调用语句中，含有的实参个数是:函数的调用形式为：函数名(实参1，实参2，……)其中实参可以是常量、变量或表达式，题目中ree2+rec3是算术表达式，(rec4，rec5)是逗号表达式。 注意逗号表达式的计算：int x=10;执行 y=(2*8,x+=5);后x=15,y=15; 特别要注意宏定义的本质，只是简单地字符替换，不要人为的加括号。 注意变量按照一定执行顺序后值的变化：int a=0;int b=a++;int c=a+(++b);执行完以上语句后：a=1,b=1,c=2; 最适合作为队列链表的是：单向循环链表 //有待验证 在具有n个顶点的有向图中，每个顶点最大的度为：n-1 若对有向图进行拓扑排序，能够得到拓扑序列的条件是：该有向图中不存在回路。 即，判断有向图中是否存在回路可以采用拓扑排序的方法、还有深度优先搜索的方法。 在最后一趟排序开始之前，序列中所有元素都不在其最终应该在的位置上，这种排序的方法是：插入排序。 无向连通图中，n个顶点，最多有n(n-1)/2条边，最少有n-1条边；有n个顶点的强连通图中，最多有n(n-1)条边，最少有n条边。 一个具有36条边的非连通无向图中至少有 10个顶点。 30题（数据结构题型分析） 对一个图进行遍历可以得到不同的遍历序列，那么导致得到的遍历序列不唯一的因素有哪些？主要原因有：开始遍历的顶点不同，采用的遍历方法不同，图的存储结构不同(即邻接表中边结点的链接次序不同)。 递归算法需要借助：堆栈 持续更新中……]]></content>
      <categories>
        <category>专业课</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F10%2F20%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown 是一种轻量级的「标记语言」，优点在于专注你的文字内容而不是排版样式。轻松的导出 HTML、PDF 和本身的 .md 文件。纯文本内容，兼容所有的文本编辑器与字处理软件。可读，直观。适合所有人的写作语言。并且具有以下特点：自动生成目录代码块高亮引用展示表格插入图片插入强调显示列表显示自动URL链接Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。语法简明概述分段 两个回车换行 两个空格 + 回车标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题强调 文字 ， 文字 ， _文字_ ， 文字 ， 文字引用 &gt; 注意后面紧跟个空格表格 - 和 | 分割行和列 ， : 控制对其方式代码块 四个空格 开头或， 使用代码内容链接 文字 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格标题 欢迎使用Markdown编辑器写博客 //一级标题 对应 标题输入 //二级标题 对应 三级标题 //三级标题 对应 四级标题 //四级标题 对应 五级标题 //五级标题 对应 六级标题 //六级标题 对应 ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行）二级标题 //二级标题 对应 —- //这里添加四个’－’ （减号） 这里不做展示了，影响目录的展示。内容强调加粗、斜体 123字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示1234字体 加粗 显示字体 _斜体_ 显示字体 加粗并斜体 显示组合 加粗并斜体 显示 字体 加粗 显示字体 _斜体_ 显示字体 加粗并斜体 显示组合 加粗并斜体 显示删除线 1这样来 删除一段文本 这样来 删除一段文本高亮 12使用`来强调字符 //想打出 (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调 比如突出背景色`来显示强调效果 使用`来强调字符比如突出背景色来显示强调效果引用显示 引用过程中任然支持Markdown语法！标准使用 12345678 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。还在引用中！两个回车结束引用！ 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。还在引用中！ 两个回车结束引用！省略使用 123456 仅第一行加应用；引用开始；引用换行；引用结束；两个回车结束引用,不在引用范围内了！ 仅第一行加应用；引用开始；引用换行；引用结束； 两个回车 结束引用,不在引用范围内了！嵌套使用 123456789101112131415 动物 水生动物陆生动物 猴子人 程序猿攻城狮产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记两栖类动物大鳄鱼唐老鸭两个回车结束引用,不在引用范围内了！ 动物水生动物陆生动物猴子人程序猿攻城狮产品狗 这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 这里需要注意，没有空行间隔，忽略降级引用标记两栖类动物大鳄鱼唐老鸭 两个回车 结束引用,不在引用范围内了！表格表格语法：12345列1 | 列2 | 列3—– | — | —-第1行 | 12 | 13第2行 | 22 | 23第3行 | 32 | 33 列1 列2 列3第1行 12 13第2行 22 23第3行 32 33可以使用冒号来定义对齐方式：1234| 左对齐 | 右对齐 | 居中 || :——– | ——-:| :–: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 左对齐 右对齐 居中Computer 5000 元 1台Phone 1999 元 1部代码块代码块语法遵循标准 markdown 代码，使用 开始， 结束，例如：12345 链接插入123首页我的纪念册 首页我的分类]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[百度云加速播放]]></title>
    <url>%2F2018%2F10%2F20%2F%E7%99%BE%E5%BA%A6%E4%BA%91%E5%8A%A0%E9%80%9F%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[使用chrome浏览器 按F12进入开发者模式→在console中输入以下的代码 videojs.getPlayers(&quot;video-player&quot;).html5player.tech_.setPlaybackRate(2) setPlaybackRate(2)中修改2到你自己适应的倍速 使用Firefox浏览器 直接在视频播放界面的右击，调整倍速即可。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[真题笔记]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[考研加油 从整体上说，”数据结构”课程主要研究：逻辑结构、存储结构、算法 三个方面的内容。在长度为n的非空队列中进行插入或者删除操作的时间复杂度是O(1)。将一颗结点总数为n,且具有m个叶节点的树转换为一颗二叉树以后，该二叉树中右子树为空的结点有：n-m+1个。要掌握建立大顶堆和小顶堆的思想和过程。要掌握递归算法和非递归算法的互相转换。在一个散列表(hash)查找中，评价一个散列函数优劣的两个主要条件是：1、值均匀分布于表空间以减少冲突2、函数尽可能简单的方便计算j简单地说就是：1、散列函数分布均匀；2、计算简单 一次排序后至少可以确定一个元素位置的有：选择排序、冒泡排序、快排、堆排序不能确定的有：插入排序、shell排序、归并排序、基数排序参考链接：https://www.nowcoder.com/questionTerminal/71f5a64431014e7fb8eda27213429a86?toCommentId=428177 每一次排序之后都能确定至少一个元素位置的排序方法包括： 1.选择排序：每次将最大的数放到最后。所以最大的数排一次序后位置就确定了。2.冒泡排序：同选择排序。每一次排序最大的值位置确定。3.快排：每一次排序pivot的位置确定。4.堆排序：每一次排序时，都是将堆顶的元素和最后一个节点互换，然后调整堆，再将堆大小减1。所以每一次排序堆顶元素确定。 不能至少确定一个元素的位置的方法包括：1.插入排序：不到最后一步求的都是相对位置。2.shell排序：对简单插入排序的改进。不到最后一步，是无法确定每个元素位置的。3.归并排序：局部有序，并不能确定任一元素在全局的位置。4.基数排序，计数排序：利用桶排序的思路，不是基于比较的排序，也无法在一次排序中确定某个元素的位置。因为每一次排序都是整体处理。 若完全二叉树的第7层有10个叶节点，则有两种情况：1、10个叶节点集中在第7层的最左边，此时可求出该二叉树的结点总数为（2^6-1）+10=73.2、该完全二叉树的深度为8，10个叶节点全部集中在第7层的最右边，此时，可求出该二叉树的结点总数为:(2^6-1)+2^7-1+108=235;或者可用：(2^8-1)+(2^6-10)*2=235。个人认为第2中方法更好理解。 C语言中，函数调用时数据的传递方式：1、参数传递方式：函数调用时根据实参传递给形参内容的不同又分为值传递和引用传递(地址传递)两种。2、通过return语句传递数据：被调用函数可以通过return语句将函数值传递给调用函数。3、利用全局变量传递数据。 共用体的3个特征：1、共同体的成员变量共用一块存储空间，共用体变量所占用的字节数等于最长成员所占用的字节数。2、共用体不能在定义的时候初始化。3、共用体中的成员每次只能有一个起作用，当存入新成员时，原来的成员失效，其值被覆盖。 C语言中，指针可以进行的运算：1、指针加减一个整数，表示以当前指针所指单元的地址为起点的后或前整数个数据的地址。2、指针减指针。表示两个地址之间的数据个数。(指针加指针为非法运算)。3、比较。表示同类型的两个指针所指对象在地理位置上的关系。 多个堆栈共享一个连续的存储空间：多个堆栈共享一个连续的存储空间，可以充分利用存储空间，只有在整个存储空间都用完时才能产生溢出，其缺点是当一个堆栈溢出时需要向左右栈查询有无空闲单元。若有，则需要移动相应元素和修改相关的栈底和栈顶指针的位置。当各个堆栈接近溢出时，查询空闲单元、移动元素和修改栈顶指针位置的操作频繁，计算复杂，并且耗费时间。 分别建立多个顺序存储结构的堆栈：每个堆栈仅用一个顺序存储空间时，操作简便，但难以确定初始分配存储空间的大小，空间分配少了，容易产生溢出，空间分配多了，容易造成空间的浪费；并且各个堆栈不能共享空间。分别建立多个采用链式存储结构的堆栈：一般情况下，分别建立多个链接堆栈不考虑堆栈的溢出(仅受用户内存空间限制)，缺点是堆栈中各元素要通过指针链接，比顺序存储结构多占用存储空间。 宏定义是用一个简单的名称代替一个长的字符串，也就是说宏名代替的是一个字符串，作用范围是定义命令之后到本文件结束。也可用#undef命令终止定义的作用域。例如：#define PI 3.14,这里PI代替的是一个字符串，而不是一个浮点数。带参宏和函数的区别： 文件包含预处理的功能是：在对源程序进行编译之前，用包含文件的内容取代该文件包含的预处理语句。 使用文件的基本操作一般有下列5(前两个步骤可以不写)个步骤：1、头文件中包括stdio.h2、定义文件指针FILE *fp3、打开/建立文件，使文件指针与磁盘中的实际存储位置的数据文件建立关联。例如：fp=fopen(“text.txt”,”r”)。4、对文件进行读写操作。例如fread(f,4,2,fp)5、文件使用完毕后，关闭文件。例如。fclose(fp)。 文件通常是存储在外部介质上的，在使用的时候才调入内存中来。从用户角度来看文件分为：普通文件、设备文件 //了解即可。从文件的存取方式来看：顺序文件、随机文件。从编码来看：ASCII文件、二进制文件。文件指针是指向一个结构体类型的指针变量。这个结构体中包含有诸如缓冲区的地址、在缓冲区中当前存取的字符位置等信息，都包含在呢头文件”stdio.h”中了，并称结构体类型名为FILE,可以用此类型名来定义文件指针。FILE *文件指针文件指针通常被称为流，输入输出函数通过流来对文件进行处理。在文件内部有一个位置指针，用来指向文件的当前读/写字节。应注意文件指针和文件内部的位置指针不是一回事。文件指针是指向整个文件的。需要在程序中用FILE定义，只要不重新赋值，文件指针的值是不变的。 以文本方式打开一个文件输出时，将换行符转换为回车换行两个字符。文件打开函数fopen(),当指定的文件不能打开或发生错误，该函数返回一个空指针NULL(0);否则返回一个非0值。fclose(文件指针)，若文件关闭成功，返回0，否则返回-1. 判断文件结束，就是判断文件指针是否指向文件末尾，feof函数用于检测文件是否结束。feof(文件指针)。若文件结束即文件位置指针在文件末尾，则返回一个非0值，否则返回0值。 文本文件以EOF(-1)作为文件结束标志，因为ASC II代码值得范围是0~255，不可能出现-1，所以编写从一个磁盘文本文件中逐个读取字符并输出到屏幕上的程序时，可以在while循环中以EOF作为文件结束标志。但二进制文件中就会有-1值得出现，因此不能采用EOF作为二进制文件的结束标志，必须使用feof()函数进行判断。 文件字符输入函数：是指从文件中读出数据，将其保存到内存变量中，文件输入是相对内存变量而言的。函数getc或fgetc用于输入一个字符。ch=getc(fp); 或者ch=fgetc(fp);fp是文件指针。文件字符输出函数：是指将保存在内存变量(输出操作是相对内存变量而言的)中的数据写到文件中。函数putc(),和fputc()用于输出一个字符。putc(ch,fp);或fputc(ch,fp);fp是文件指针。若函数执行成功，则把字符写入到指定的文件；否则返回文件结束标志EOF(-1)。 会计算各种排序经过一次排序或者排好序后元素的移动次数或比较次数。 数组：数组定义后，不能再对数组进行整体赋值例如：int a[3];a[3]={1,2,3} //是错误的。 sizeof()和strlen()计算字符串长度时的区别：sizeof()和strlen()都计算空格，并且sizeof计算’\0’,strlen()不计算’\0’,也就是说，sizeof计算出来的结果比strlen计算出的结果大1。]]></content>
      <categories>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[结构体和联合体]]></title>
    <url>%2F2018%2F10%2F18%2F%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93%2F</url>
    <content type="text"><![CDATA[当多个数据需要共享内存或者多个数据每次只取其一时，可以利用联合体(union)。在C Programming Language 一书中对于联合体是这么描述的： 1)联合体是一个结构； 2)它的所有成员相对于基地址的偏移量都为0； 3)此结构空间要大到足够容纳最”宽”的成员； 4)其对齐方式要适合其中所有的成员；下面解释这四条描述： 由于联合体中的所有成员是共享一段内存的，因此每个成员的存放首地址相对于于联合体变量的基地址的偏移量为0，即所有成员的首地址都是一样的。为了使得所有成员能够共享一段内存，因此该空间必须足够容纳这些成员中最宽的成员。对于这句”对齐方式要适合其中所有的成员”是指其必须符合所有成员的自身对齐方式。例如，代码： union U { char s[9]; int n; double d; }; s占9字节，n占4字节，d占8字节，因此其至少需9字节的空间。然而其实际大小并不是9，用运算符sizeof测试其大小为16.这是因为这里存在字节对齐的问题，9既不能被4整除，也不能被8整除。因此补充字节到16，这样就符合所有成员的自身对齐了。从这里可以看出联合体所占的空间不仅取决于最宽成员，还跟所有成员有关系，即其大小必须满足两个条件：1)大小足够容纳最宽的成员；2)大小能被其包含的所有基本数据类型的大小所整除。测试程序： 对于sizeof(u1)=16。因为u1中s占9字节，n占4字节，d占8字节，因此至少需要9字节。其包含的基本数据类型为char，int，double分别占1，4，8字节，为了使u1所占空间的大小能被1，4，8整除，则需填充字节以到16，因此sizeof(u1)=16.对于sizeof(u2)=8。因为u2中s占5字节，n占4字节，d占8字节，因此至少需要8字节。其包含的基本数据类型为char，int，double分别占1，4，8字节，为了使u2所占空间的大小能被1，4，8整除，不需填充字节，因为8本身就能满足要求。因此sizeof(u2)=8。从打印出的每个成员的基地址可以看出，联合体中每个成员的基地址都相同，等于联合体变量的首地址。(代码省略)对u1.n=1，将u1的n赋值为1后，则该段内存的前4个字节存储的数据为00000001 00000000 00000000 00000000因此取s[0]的数据表示取第一个单元的数据，其整型值为1，所以打印出的结果为1.关于结构体和联合体所占内存空间大小的问题： // Created by z lin zhang on 2018/10/16. #include &lt;stdio.h&gt; union U1 { char s[ 9 ]; int n; double d; }; union U2 { char s[ 5 ]; int n; double d; }; struct student{ char A; int B; short C; }student1; struct tagPhone{ char A; short C; int B; }Phone2; struct str2 { double a; int b; char c; double d; }str21; int main(){ union U1 u1; union U2 u2; printf(&quot;char short int float double is %d %d %d %d %d\n&quot;, sizeof(char), sizeof(short), sizeof(int), sizeof(float),sizeof(double)); printf(&quot;u1 is %d\n&quot;, sizeof(u1)); printf(&quot;u2 is %d\n&quot;, sizeof(u2)); printf(&quot;student1 is %d\n&quot;, sizeof(student1)); printf(&quot;phone2 is %d\n&quot;, sizeof(Phone2)); printf(&quot;str21 is %d\n&quot;, sizeof(str21)); } 输出结果是：u1 is 16u2 is 8student1 is 12phone2 is 8str21 is 24char short int float double is 1 2 4 4 8r]]></content>
      <categories>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树与二叉树]]></title>
    <url>%2F2018%2F10%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树与二叉树任何非空树只有一个结点没有直接前驱结点：根结点。包括根结点在内，所有的结点都可以有多个直接后继结点。树形结构是一种具有递归特征的数据结构树形结构中的数据元素之间存在的关系通常是一对多、或者多对一的关系。 //了解即可、不是重点树的几种逻辑表示方法：（https://baijiahao.baidu.com/s?id=1603537434407228548&amp;wfr=spider&amp;for=pc）1、树形表示法2、文氏图表示法3、凹入表示法4、嵌套括号表示法 下面的定义以上图为参考(忽略箭头)。结点的度：结点拥有的子树的数目称为该结点的度数。树的度：树中各结点度的最大值被定义为该树的度（不是指对结点的度求和），叶子结点：度为0的结点称为叶子结点或者终端结点，简称叶结点，叶结点没有子孙结点。分支结点：度不为0的结点称为分支结点或非终端结点。结点的层次：从根结点所在的层开始为第1层，根结点的孩子结点为第2层…某结点在第i层，其孩子结点在i+1层。树的深度（高度）：树中结点的最大层次树被定义为该树的深度或者高度。孩子：结点的子树的根双亲：与孩子的定义相应兄弟：同一个双亲的孩子之间的互为兄弟。祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。子孙：以某结点为根的子树中的所有结点，都是该结点的子孙。层次：从根开始，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层，以此类推。结点的深度和高度：结点的深度是从根节点开始算起的，根节点的深度为1；结点高度是从最底层的叶子结点算起的，最底层叶子结点的高度为1。堂兄弟：双亲在同一层的结点互为堂兄弟。如G和H互为堂兄弟，因为G的双亲是C，H 的双亲是D，C和D在同一层上，注意和兄弟概念的区分。有序树：树中结点的子树从左到右是有次序的，不能交换，这样的树叫做有序树。无序树：树中的结点的子树没有顺序，可以任意交换。丰满树：即理想平衡树，要求除最底层外，其它层都是满的。森林:m(m&gt;=0)棵不相交的树的集合被称为森林或者树林。对树中每个分支结点来说，其子树的集合就是一个森林。有序树：树中结点子树的相对次序不能随意变换，或者说改变前后的树表示的不是同一个对象，则称该树为有序数。本书着重讨论有序树，无序树总可能转化为有序树加以研究。森林：若干棵互不相交的树的集合，例子中如果把根A去掉，剩下的3棵子树互不相交，它们组成一个森林。 考研不会考概念，在题目中见到的多了就记住了，概念只是一个工具。 二叉树的六大性质：//重点1、非空二叉树的结点总数等于树中所有结点的度之和加1。2、二叉树的第i层最多有2^(i-1)(i&gt;=1)个结点。3、高度(或深度)为k的二叉树最多有(2^k)-1个结点。换句话说就是：高度为k时，若其为满二叉树，其结点最多。用等比数列的求和公式。4、具有n个结点的完全二叉树，对各结点从上到下，从左到右依次编号(编号范围为1~n),结点之间有如下关系：若其某个结点a的编号为i,(i!=1),则a的双亲结点的编号为i/2向下取整。若2i&lt;n,其左孩子的结点编号为2i,若2i&gt;n,则其无左孩子。若2i+1&lt;n,其右孩子的结点编号为2i+1,若2i+1&gt;n,则其无右孩子。5、函数catalan(),对于有n个结点的二叉树，可以构成(从2n中选n个出来的个数)/(n+1)。6、具有n(n&gt;=1)个结点的二叉树，其高度(深度)为{向下取整(log2 n)}+1。 二叉树的存储结构1、顺序存储结构 //了解即可顺序存储结构中最简单直观的就是双亲存储结构，用一维数组就可以实现。int tree[maxSize];即用一个整型数组就可以存储一棵树的信息。下标1上的内容为-1，即表示1为根节点，用这种存储结构来存储树，当知道一个结点后就很容易找到其双亲结点，因此称为双亲存储结构。树的双亲存储结构在克鲁斯卡尔算法中有重要应用。2、链式存储结构 //重点lchild data rchile 树的链式存储结构最常用的有以下两种：（1）孩子存储结构 其实质就是：图的邻接表存储结构，树就是一种特殊的图，把图中的多对多关系删减为一对多关系即得到树，因此图的存储结构完全可以用来存储树。（2）孩子兄弟存储结构 二叉树定义：每个结点最多只有两棵子树，即二叉树中结点的度只能为：0、1、2.子树有左右顺序之分，不能颠倒。(有序树)二叉树有5种基本的形态：空二叉树、只有根节点、只有左子树、只有右子树、左右子树都有。 在一棵二叉树中：如果所有的分支结点都有左孩子结点和右孩子结点，并且叶子结点都集中在二叉树的最下一层，则这样的二叉树被称为满二叉树。完全二叉树：对满二叉树进行编号，约定编号从1开始，从上到下，从左到右进行，如果对一棵深度为K、有n个结点的二叉树进行编号后，各结点的编号与深度为K的满二叉树中相同位置上的结点的编号均相同，那么这棵树就是完全二叉树。通俗的说：一棵完全二叉树一定是由一个满二叉树从右至左从下至上，挨个删除结点所得到的，如果跳着删除，则得到的不是完全二叉树。 树的基本操作：1、建立一颗空树，SETNULL(T)2、求结点x所在树的根结点，或者求树T的根结点，ROOT(x)或者ROOT(T)。3、求树T中结点x的双亲结点，PARENT(T,x)4、求树T中结点x的第i个孩子结点，CHILD(T,x，i)5、求树T中结点x右边的兄弟结点，RIGHTSIBLING(T,x)6、把以s为根的树插入到树T中作为结点x的第i颗子树。INSERT(T,x,i,S)7、删除树T中结点x的第I颗子树，DELETE(T,x,i)8、对一棵树进行遍历，即按照某个次序依次访问树中所有结点，每个结点仅被访问一次，得到一个由所有结点组成的序列，TRAVERSE（T） 多重链表表示法：每个链结点有一个数据域和若干个指针域组成，其中，每一个指针域指向该结点的一个孩子结点。由于在一棵树中，其度数不同，每个结点设置的指针域的数目就有不同的考虑。 树的遍历https://blog.csdn.net/weixin_42616808/article/details/81158766树的先序、中序、后序遍历是(针对于访问根节点的次序而言的),最先访问根节点，则为先序遍历；中间访问根节点则为中序遍历；最后访问根节点，则为后序遍历。代码：void order(BTnode *p){visit(p); //(1)先序遍历 //visit()是已经定义过的。(1)、(2)、(3)对应的分别是先序、中序、后序遍历。order(p-&gt;lchild);visit(p); //(2)中序遍历order(p-&gt;rchild);visit(p); //(3)后序遍历 } 层次遍历需要建立一个循环队列层次遍历就是从左到右、或者从右到左对每个结点依次访问。代码： void level(BTNode p) { int front, rear; BTNode que[maxSize]; // 定义一个循环队列，用来记录将要访问 // 的层次上的结点 front = rear=0; BTNode *q; if(p!=NULL) { rear=(rear+1)%maxSize; que[rear]=p; // 根节点入队 while(front!=rear) //当队列不空的时候进行 循环 { front=(front+1)%maxSize; q = que[front]; // 队头结点出队 Visit(q); //放问队头结点 if(q-&gt;lchild!=NULL) //如果左子树不空，则左子树的根结点入队 { rear=(rear+1)%maxSize; que[rear]=q-&gt;lchild; } if(q-&gt;rchild!=NULL) // 如果右子树不空，则右子树的根节点入队 { rear=(rear+1)%maxSize; que[rear]=q-&gt;rchild } } }} 参考了：https://zhuanlan.zhihu.com/p/36823220 5.二叉树的存储结构（1）顺序存储结构：（数组） 下标从1开始，左孩子2i， 右孩子2i+1适合存放完全二叉树和满二叉树（这样不会浪费空间）（2）链式存储结构： （至少包含3个域 左孩子lchild， 数据域data， 右孩子rchild）typedef struct BiTNode { ElemType data; struct BiTNode lchild, rchild;}BiTNode, *BiTree;重要结论：含有n个结点的二叉链表含有n+1个空域（可以利用这些空链域来组成线索链表）。（2）非递归算法（需要掌握）①先序遍历（栈）：右孩子先进栈，左孩子后进栈②中序遍历（栈）：如果栈顶结点左孩子存在，则左孩子入栈。 若左孩子不存在，则出栈并输出栈顶，再看右孩子是否存在。若存在就把右孩子进栈③后序遍历（很多种方法）④层次遍历（队列）:用一个队列， 若队列不空，出队一个元素并输出，把其左右孩子分别入队（若不空）前序和后序序列相反，则二叉树只有一个叶子结点，即不存在一个结点同时又两个孩子。只有一下这两种形态，如下图 。]]></content>
      <categories>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-数组]]></title>
    <url>%2F2018%2F10%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[考研加油 大纲要求：三、数组1．一维数组和二维数组的存储；2．矩阵的压缩存储的基本概念；3．对称矩阵、对角矩阵以及三角矩阵的压缩存储。 简单的说，数组就是：下标与值组成的数偶的有限集合。数组一般没有插入和删除操作，也就是说，数组一旦被定义，它的维数和维界就不再改变，数组的规模是固定的，称之为静态结构。对于一个数组来说，在申明时，其长度（内存空间）就已经确定，不可随意更改（不能动态变化），因此其一旦被定义，它的维数就不再改变，数组的规模是固定的，也成为静态数组。在定义一个二维数组时，其一维大小可以省略，但是其二维大小不可省略，例如：int a[][6],但是不可写成int a[][]或int a[6][]。C语言中求一个数组的长度：sizeof(a)/size(type(a)) //a为数组名，用sizeof(a)去除以数组类型的sizeof,就是数组的长度，即元素的个数。 数组的主要几种操作：给出一组下标，检索对应的数组元素。给定一组下标，存、取或者修改对应数组元素的值。检索满足条件的数组元素。对数组的所有元素按照值得大小进行升序或者降序排序。 数组的存储结构：一般都采取顺序存储结构。只要确定了数组的维数和各维的上下界，就可以为他们分配存储空间。p64:已知某数组元素的存储位置，求另一个位置的存储位置。（不只是一维数组，二维数组更应该重点看，必须掌握） 矩阵的压缩存储：是指为多个值相同的元素只分配一个存储空间，而对值为0的元素不分配存储空间。对称矩阵的压缩存储：若一个矩阵A满足aij=aji，1&lt;=i,j&lt;=n，则其为对称矩阵。对角矩阵的压缩存储：对角矩阵：矩阵中的所有非零元素都集中在以主对角线为中心的带状区域中，即除了主对角线上和直接在主对角线上，下方对称的若干对角线上的元素，其余元素均为零。 稀疏矩阵的三元组表表示：稀疏矩阵的三元组表存储方法对于矩阵中的每一个元素，用一个三元组就可以表示出来（i,j,value）。i,j分别为行，value为该元素值。稀疏矩阵的转置算法：一个稀疏矩阵转换后还是稀疏矩阵稀疏矩阵的加法、乘法 稀疏矩阵的链表表示： 线性链表的表示方法： 线性链表存储方法，方法之一就是：将所有的非零元素以行序为主序的方式采用循环链表链接起来。链结点的构造由4个域组成: 以行序为主序，以列序为主序的特点，在已知某一个元素的位置后，求解另一个元素的位置，即元素位置的计算。row col value link另外，为整个链表设置了一个表头结点。m n t link其中m,n分别表示行列，t为稀疏矩阵中非零元素的总个数，link域为指针域，用以指向第1个非零元素对应的链结点。若采用以行序为主序的方式，依次将所有非零元素链接起来，这种表示方法最明显的一个缺点就是：当要访问某行某列的一个非零元素时，必须从链表的最前面那个链结点开始进行搜索，其效率很低。 带行指针向量的链表存储方法另外一种采用链表存储稀疏矩阵的方法是带行指针向量的链表结构。在这种链表结构中，将具有相同行数的元素所对应的链结点按照列号从小到大的顺序链接成一个线性链表，也就是说，稀疏矩阵中的每一行对应着一个线性链表。……十字链表存储方法：这种方法不仅为稀疏矩阵的每一行设置了一个单独的行循环链表，同样也为每一列设置了一个单独的列循环链表。这样稀疏矩阵的每一个非零元素同时包含在两个链表中，即包含在它所在的行链表和所在的列链表，也就是这两个链表的交汇处。…… 数组的应用：//大纲没作要求 一元多项式的数组表示：方法一：定义一个数组A[0,n+1],A[0]用来存放多项式A（x）的阶数n，从第二个数组元素A[1]到第n个数组元素A[n+1]依次用来存放A(x)的n+1个系数An,An-1，An-2…..A0.也就是说，多项式中各个系数以指数递减顺序进行存储。缺点：当多项式的最高次项和最低次项之间缺项很多的时候，显然就不必用很多的存储空间来存储为0的系数。这个时候宜采用方法二。方法二：定义一个一维数组A[0,,,2m]来存储多项式。其中第1个数组元素A[0]存放多项式中系数的非零项的总项数m（设非零项总项数为m），从第2个元素到第2m+1个元素（一共2m个数组元素）依次存放系数非零项的系数与指数偶对（一共m个这样的偶对）。]]></content>
      <categories>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-堆栈和队列]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[“-&gt;”用于指向结构成员，它的左边应为指向该结构类型的指针（结构指针），而”.”的左边应为该结构类型的变量（结构变量），如已定义了一个结构体struct student，里面有一个int a；然后有一个结构体变量struct student stu及结构体变量指针struct student *p；且有p=&amp;stu，那么p-&gt;a和stu.a表示同一个意思。 堆栈简称为栈（stack）,是一种只允许在表的一端进行插入和删除操作的线性表，允许操作的一端成为栈顶，栈顶元素的位置由一个被称为栈顶指针的变量给出，另一端则称为栈底，表中没有元素时，称之为空栈。堆栈的插入操作简称为入栈或进栈，删除操作称为出栈或退栈。其元素按照先进后出（FILO）的原则进行的。正因为如此，也称堆栈为后进先出表或者下推表。堆栈是一个动态的结构，随着元素的进出，堆栈的状态是不同的。栈顶元素始终是最上面那个元素。堆栈的基本操作：1、初始化一个堆栈2、测试堆栈是否为空栈；当栈顶为空时，返回一个真值；否则返回一个假值。这是对堆栈进行删除操作或取当前栈顶元素操作之前的必要操作。3、测试堆栈是否已满。当堆栈已满时，返回一个真值；否则返回一个假值。这个操作通常是在堆栈采用顺序存储结构时，对堆栈做插入操作之前需要进行的一个操作。4、在堆栈的顶端位置插入一个新的数据元素，简称为进栈或者入栈，该操作相当于在线性表的最后那个元素位置插入一个新的数据元素。显然该操作会改变栈顶指针的位置。5、删除堆栈的栈顶元素。简称出栈或退栈，在实际的应用中，被删除的数据元素往往有某种用途，因此可以将该操作定义为一个函数，函数返回栈顶元素，并从堆栈中删除它，有的处理方法是在进行删除动作之前先保存被删除的元素。该操作也会改变栈顶指针的位置。(改变栈顶指针位置)6、取当前栈顶元素。该操作与5不同，不改变栈顶指针的位置。 堆栈的顺序存储结构最简单的：可用一个数组来描述堆栈的顺序存储结构。一般将采用顺序存储结构的堆栈将成为顺序堆栈。 顺序堆栈的构造在实际程序的设计中，堆栈的顺序存储结构可以利用一个具有M个元素的数组STACK[0..M-1]来描述。其中，STACK作为堆栈的名字，数组的上届M表示堆栈的最大容量。定义一个整型变量top作为堆栈的栈顶指针，它指出某一时刻堆栈栈顶元素的位置。STACK[0]为第一个进入堆栈的元素。STACK[TOP]为当前的栈顶元素，当堆栈为空时，top=-1。由于堆栈是一个动态结构，而数组是一个静态结构，因此利用一个静态结构的数组描述一个动态结构的堆栈，存在着所谓的溢出问题。当堆栈中已经有M个元素时，如果此时再做进栈操作则会产生溢出，称这种现象为上溢；对空栈进行删除操作也会产生溢出，称之为下溢。为了避免溢出，在对堆栈进行进栈操作和退栈操作之前，应该分别测试堆栈是否已满或者是否为空。 顺序堆栈的基本算法： 空栈的top==-1。 初始化一个堆栈top=-1; 测试一个堆栈是否为空return top==-1;检测top是否为-1即可。 测试堆栈是否已满return top=Maxsize-1;若已满，则返回1，否则返回0； 取当前栈顶元素前提是：堆栈不为空，即在进行取操作之前要检测堆栈是否为空。 插入（进栈）该算法在容量为M的堆栈中插入一个新的数据元素item,栈顶元素位置由top指出。新的数据元素进栈之前首先测试上溢条件，若产生溢出，则算法返回0，表示插入失败，算法结束；否则，将栈顶指针top向前移动一个位置，然后将新的数据元素item插入修改以后的top指出的新的栈顶位置上，并且算法返回1，表示本次插入成功。 删除（退栈）该算法从堆栈中退出当前栈顶元素。并保存在变量item中，同时修改栈顶指针的位置。删除前先要判定堆栈是否为空，若为空则算法返回0，删除失败。算法结束；否则，若栈顶元素有保留的必要，则将其留在item中，然后将栈顶指针后退一个位置，并且算法返回1，表示删除成功。这里所谓的删除是指：将栈顶指针后退一个位置，原来栈顶位置中保存的元素依然存在，只是被认为不作为当前栈中的元素而已，（实际上该元素还占据着原来的我只，当有新的数据元素进栈时就会将其冲掉） 无论是退栈还是入栈操作关键的一步就是：修改栈顶指针top的位置。显然，上述几种算法的复杂度均为O(1)，与堆栈的长度无关。 多个堆栈共享连续空间将多个堆栈顺序地映射到一个已知大小为M的存储空间STACK[0..M-1]上，如果只有两个堆栈来共享M个存储空间，问题比较容易解决，只需要让第1个堆栈的栈底位于STACK[0]处，而让另一个堆栈的栈底位于STACK[M-1]处，优点：节省空间，缺点：需要移动大量的数据元素，时间代价较高，尤其是当存储空间即将充满的时候。 堆栈的链式存储结构简称为：链式堆栈或链栈。链式堆栈就是采用一个线性表实现一个堆栈结构。栈中的每一个元素用一个链结点表示，同时设置一个指针变量（用top表示），指出当前栈顶元素所在链结点的存储位置。当栈顶为空时，有top为NULL,例如：a,b,c,d是个元素放入一个栈中，如下：top—&gt;d—-&gt;c—&gt;b—-&gt;a null 链表不必设置头结点，链表的第一个链结点就是栈顶元素所在的链结点，最先进入堆栈的元素一定在链表末尾那个链结点中， 链接堆栈的基本算法： 链接堆栈的初始化top=null测试链接堆栈是否为空Return(top=NULL)取当前栈顶元素 链接堆栈的插入 链接堆栈的删除 从链接堆栈中删除一个元素相当于删除线性表的第一个结点。堆栈为空，删除失败，返回0；不为空，则保存被删除结点的数据信息，释放被删除结点，堆栈非空，删除成功，返回1. 以上算法的时间复杂度均为O(1)。 堆栈的应用： 在实际运用中，需要满足”先进后出/后进先出”的原则就可以使用堆栈，在递归过程的实现与函数之间的调用等也都离不开堆栈结构。 1、符号匹配检查 核心思想：（以花括号和圆括号为例）首先创建一个空的堆栈，依次读入字符直到文件的末尾。如果读得的字符为左花括号和=或左圆括号，则将其压入堆栈。如果读得的字符是右花括号或者右圆括号，而此时堆栈为空，则出现不匹配现象，报告错误；否则，退出当前栈顶元素。如果退出的栈顶符号不是对应的左花括号或左圆括号，则出现不匹配，报告错误。读到文件末尾，若堆栈为非空，则报告错误。 2、数制转换对于给定的任意一个无符号十进制整数num，录如何依次输出与其等值的八进制的各位数字。把一个十进制整数转换成八进制的过程可以是反复的执行以下动作。1将num除以8，取其余数。2判断商是否为0，若为0，则转换至此结束，若商不为0，则将商送num，转到第一步。将得到的余数依次送入一个堆栈保存，最后按照退栈的次序依次打印栈中的各元素即可。 p96 堆栈在递归中的应用用递归的好处：程序简洁，看上去清晰，程序结构符合结构化程序设计，可读性好，并且易于验证其正确性。递归：一个较为简单的说法就是：一个表达式中又包含了其本身。比如求解阶乘。自己调用自己的过程称为：直接递归。间接调用自己的过程称为：间接递归。一个递归必须有明确的含义，也就是说，递归定义必须一步比一步简单，最后有终结，不能无限循环下去，过程中最简单的那一步称为递归出口，它本身不再使用递归的定义。 递归过程的实现： p98 表达式的计算： 重点 队列的概念及其操作队列的定义：队列简称队，是一种只允许在表的一端进行插入操作，另一端进行删除操作的线性表。允许插入的一端称为队尾，队尾元素的位置由一个变量（设为rear）指出，允许删除的一端称为队头，队头元素的位置由另一个变量（设为front）指出。没有元素的队列称为空队。从队列中删除元素叫出队，元素出队后，其后继元素就成了新的队头元素。 进入队列或退出队列都是按照 “先进先出” FIFO 原则进行的，因此，队列也称为先进先出表。 队列和堆栈一样 也是动态结构，当一个队列的元素已经确定时，其出队和进队的顺序是固定的。任何一次排队的过程都形成一个队列，反映了 “先来先服务”的处理原则队列的基本操作和堆栈类似：1、初始化一个队列2、在队尾插入一个元素， 堆栈是先进后出，只能在表尾进行删除和插入操作，（只能在一端对其进行操作），当栈为空时 定义top=-1,有一个元素时top=0; 顺序栈:对于顺序栈st，一共有4个要素，包括两个特殊状态和两个操作。1）栈空状态St.top==-12）栈满状态St.top==maxsize-1,maxsize为栈中最大的元素个数，本书规定top==-1时栈空，非法状态（上溢和下溢）栈满就是一种继续入栈就会上溢的状态，对应的栈下溢就是栈空的时候继续出栈造成的结果。2）两个操作1、元素X进栈操作：++（st.top）;st.data[st.top]=x;既然规定了top==-1时栈为空，则元素进栈操作就必须是先移动指针，再进入元素，因为数组的下标不存在-1，2、元素X的出栈操作：X=st.data[st.top];–(st.top);进栈的操作次序决定了出栈的操作次序，由于进栈操作是先移动指针，再存入元素，因此出栈的操作就必须是：先取出元素再移动指针。 定义一个栈并且初始化栈：st.top=-1;int stack[maxSize];int top=-1; 判断栈空的代码：If(st.top==-1) return 1;else return 0; 进栈操作：if(st.top==maxsixe-1) //先判断栈是否已满 return 0;stack[++top]=x; 出栈代码：if(st.top==-1) //先判断栈是否为空 return 0;x=stack[top–]; 链栈和顺序栈对应，链栈也有4个要素，包括两个特殊状态和两个操作。两个状态：11）栈空状态lst-&gt;next=NULL;2）栈满状态一般不存在栈满的情况，（高分笔记p59）两个操作：1）元素（由指针p所指）进栈操作p-&gt;next=lst-&gt;next;lst-&gt;next=p; //其实就是头插法建立链表中的插入操作2）出栈操作（出栈元素保存在x中）p=lst-&gt;next;x=p-&gt;data;lst-&gt;next=p-&gt;next;free(p); //其实就是单链表的删除操作 链栈的初始化代码：void initStack(LNode&amp;lst){lst=(LNode)malloc(sizeof(LNode));lst-&gt;next=NULL;} 判断栈空代码：当栈空时返回1，否则返回0int isEmpty(LNode *lst){if(lst-&gt;next==NULL) return 1;else return 0;} 进栈代码：void pust(LNode lst,int x){LNode p;p=(LNode*)malloc(sizeof(LNode));p-&gt;next=NULL; /一下3句就是链表的头插法/p-&gt;data=x;p-&gt;next=lst-&gt;next;lst-&gt;next=p;} 出栈代码在栈不为空的情况下可以执行，返回1，否则返回0，代码如下：int pop(LNode lst,int &amp;x){LNode p;if(lst-&gt;next==NULL) return 0;/以下就是单链表的删除操作/p=lst-&gt;next;x=p-&gt;data;lst-&gt;next=p-&gt;next;free(p);return 1;}//在考研中，对链栈代码的考察比顺序栈少得多，建议在顺序栈上多下功夫。 栈的应用1、括号匹配：（顺序栈的应用）需要用栈来解决的问题：即在解决问题的过程中出现了一个子问题，但凭现在的条件不能解决它，需要记下，等待以后出现可以解决它的条件再返回来解决。这种问题就需要栈来解决，栈具有记忆的功能，这是栈的FILO特性所延伸出出来的一种特性。2、编写一个函数，求后缀式的数值，其中后缀式存于一个字符数组exp中， 链栈的应用：1、用不带头结点的单链表存储链栈，设计初始化栈，判断栈是否为空，进栈和出栈等相应的算法。不带头结点的单链表lst为空的条件是lst=NULL,进栈和出栈操作都是在表头进行的。 队列：顺序队： 循环队列： 循环队列的4个要素：队空状态：qu.rear=qu.front;队满状态：（qu.rear+1）%maxsize==qu.front.操作：元素X进队操作（移动队尾指针）qu.rear=(qu.rear+1)%maxsize;qu.data[qu.rear]=x;元素x出队操作（移动队首指针）qu.front=(qu.front+1)%maxsize;x=qu.data[qu.front]; 初始化队列算法：void initQueue(sqQueue &amp;qu){qu.front=qu.rear=0;} 判断队空：int isQueueEmpty(sqQueue qu){if(qu.front==qu.rear) return 1;else return 0;} 进队算法：int enQueue(sqQueue &amp;qu,int x){if((qu.rear+1)%maxsize==qu.front) //队满的判断条件 return 0;qu.rear=(qu.rear+1)%maxSize; //若队未满，则先移动指针qu.data[qu.rear]=x; // 再存入元素 return 1;} 出队算法：int deQueue(sqQueue &amp;qu,int &amp;x){if(qu.front==qu.rear) return 0;qu.front=(qu.front+1)%maxsize; //若队不空，则先移动指针x=qu.data[qu.front]; //再取出元素 return 1;} 掌握中缀式转化为后缀式。//按照优先级和结合性，依次写出运算对象，把运算符写在运算对象后面，比如：写出表达式a(b+c)-d的后缀表达式a(b+c)-db c 先进行加运算，写成 bc+然后a与（bc+）作乘法运算：abc+最后与d作减运算,即：abc+d-其他的同理可进行计算 共享栈满的条件：top2-top1=1时 2.栈 选择题判断技巧（1）抓住第一个出栈的元素，第一个入栈元素之前的元素相对位置一定不变。如： 入栈顺序为 a b c d e， 求第一个出栈字母是d的可能出栈的循序序列解：我们第一个出栈元素是dd ← topcba在d出栈时， c b a已经被push进栈了, 所以 c b a 的相对顺序是无法改变的。即可能的序列：d e c b ad c e b ad c b e ad c b a e所以得出结论： Xi出栈, Xi前未出栈元素一定逆置有序。 （4）对于n个不同的元素进栈，出栈序列个数为：catalan()函数 3.栈的应用（1）回文判断：把一半的元素放出栈中，然后将链表前一半元素依次出栈，边出栈（pop）边与后一半进行比较。（奇数时，中间不用比较）（2）括号匹配：算法思想:①初始化设置一个空栈，顺序读人括号②若是右括号”）”， 消除置于栈顶的”（”消解， 否则不合法。③若是左括号”（”，则作为一个新的更急迫的期待压入栈中。算法结束时： 栈空 success 否则 fail（3）表达式求值：中缀表达式转后缀表达式 ： 从左往右扫 →①若 当前op &gt; 栈顶op 压栈push②若 当前op &lt;= 栈顶op 出栈pop【若是”（”，直接push， “）”不断弹出直至”（”】③直到中缀表达式扫描完毕，若操作符栈中还有元素依次出栈输出到后缀表达式中PS:同理 中缀转前缀 从右往左 ←把判断条件①的”&gt;”换成”&gt;=”，把判断条件②的”&lt;=”换成”&lt;”（4）计算后缀表达式①从左到右扫描后缀表达式，如果是操作数压栈，如果是操作符（op）就弹出两个操作数（后弹出的是第一个操作数，先弹出的是第二个操作数）②操作符操作，生成新的数压栈push③直到后缀表达式扫描完毕，这时栈中只有一个元素，即所求。队列（先进先出FIFO）一种只能在表的一端插，另一端删除的单链表。顺序队（1）顺序存储结构：front指向队头，rear指向队尾元素的下一个位置（具体题目具体分析）循环队列（不循环会有假溢出）：①利用”%”来实现循环，所有操作都 + “%MaxSize “②初始：Q.front = Q.rear = 0;出队：队首+1： Q.front = （Q.front + 1） % MaxSize入队：队尾+1： Q.rear = （Q.rear + 1） % MaxSize队列长度：（Q.rear + MaxSize - front） % MaxSize队空： Q.front == Q.rear队满： （Q.rear + 1） % MaxSize == Q.front。//循环简易写法， 开始写代码需要队列时候就这么写//(front rear] front所在位置在队头元素的前一个， rear所在位置为当前队尾元素。int que[maxSize]; int front = 0, rear = 0; //定义和初始化 rear = (rear + 1) % maxSize; //入队 先移指针后入队que[rear] = x; front = (front + 1) % maxSize //出队 先移指针后出队x = que[front]; rear == front; //队空(rear + 1) % maxSize == front //队满（2）链式存储结构： 头指针指向头结点，尾指针指向队尾结点一般设头结点（不存数）比较方便，可以统一插入和删除操作（跟链表一样）PS: 注意出队时只有一个结点的时候，要把Q.rear = Q.front（即修改尾指针，具体看辅导书课本）（3）双端队列： （会手工模拟就行，而且不是重点）①输出受限（只能在一端出队）：做题思路： 因为出队确定， 所以观察模拟其能不能有题中入队的情况五、队列的应用（1）二叉树的层次遍历， 图的广度优先搜索（2）缓冲区（主机或外部设备）， 就绪队列（多用户资源竞争）等 参考：https://blog.csdn.net/qq_35924276/article/details/81384826?utm_source=copy]]></content>
      <categories>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表：单链表、双链表、循环单链表、循环双链表、静态链表(用一维数组表示)。循环单链表可以实现：从任意一个结点出发访问指针域中的任意一个结点。顺序表插入元素平均移动一半的元素；链表不需要移动元素，只需要修改指针。时间复杂度为：O(n)。对于静态链表：一般的链表结点的空间来自于整个内存，但是静态链表则来自于一个结构体数组。数组中的每一个结点的含有两个分量：一个是数据元素分量data,一个是指针分量，指示了当前结点的直接后继结点在数组中的位置（这和一般链表中next指针的地位是同等的）。 顺序表和链表的比较：关于存储空间的比较：顺序表是一次分配，链表的存储空间是多次分配的。(各有各的优缺点)。关于存储密度：顺数表的存储密度=1；链表的存储密度&lt;1。故顺序表对空间的利用率高于链表。基于时间的比较：1)顺序表可以随机存取，也可以顺序存取，（一般只说随机存取）；链表只能顺序存取（所谓的顺序存取就是：比如，要读取某个元素必须遍历其前面所有元素才能找到它并读取）2)插入和删除时移动元素的个数顺序表平均需移动一半的元素；链表不需要移动元素，只需修改指针。对于顺序表来说，进行删除操作和插入操作时，其算法的平均时间复杂度均为O(n)。 线性表的结构体定义和基本操作：//考试中顺序表的定义int A[Maxsize];int n;12345//单链表的定义 typedef struct LNode&#123; int data; struct LNode *next; &#125;LNode; //双链表的定义typedef struct DLNode{int data;struct DLNode prior;struct BLNode next;}BLNode; 顺序表的操作：对于顺序表一般就两种操作：插入和删除操作，都极其简单。注意点：1、顺序表的插入操作是先移动元素再插入元素，插入的过程是对顺序表进行遍历，直到满足条件：x&lt;L.data[i]时，那么i就是元素x的插入位置。删除操作是直接移动元素，但是移动元素时要注意移动的方向不能错了，否则会导致元素被覆盖。也就是说将后面的元素前移2、插入的位置必须是:1&lt;=i&lt;=n+1,删除时平均移动次数为：（n-1）/2，平均时间复杂度为：O（n），顺序表的优点：存储密码大，对空间的利用率更高，可以随机访问。3、因为插入和删除都L都会改变，故在定义时要用引用型。比如：插入元素，int insertElem(Sqlist &amp;L,int p,int e){} 静态链表存储结构与顺序存储结构相比，其优点是：便于插入和删除。线性表采用链式存储结构时，其结点地址：连续与否都可以。如果最常用的操作是取第i个元素的前驱结点，则采用顺序表的存储方式最节省时间。需要分配较大的连续空间，且插入和删除不需要移动元素的线性表，其存储结构是：静态链表。静态链表中指针指示的是：链表中下一元素在数组中的地址。 单链表的操作(本书默认所有的链表都有头结点) typedef struct LNode{int data;struct LNode *next;}LNode;线性表的链式存储：不要求在逻辑上相邻的元素在物理地址上也相邻，即：地址空间不一定是连续的。在删除和插入操作时，不需要移动元素，只需要修改指向元素的指针即可，其由被称为链结点 构成，链结点有：指针域和数据域构成。(链结点内部的地址一定是连续的，链结点之间的地址不一定连续，也就是可以连续也可以不连续)。进行插入和删除操作之前都要先对表进行检查，检查表的位置是否已满或者表是否为空(一般只检查是否为空，不检查是否为满，因为一般不会满，除非题目有特殊说明)。插入操作：（1&lt;=i&lt;=n+1）1、先构造一个新结点，用S指向。2、再找到链表的第i-1个结点，用p指向。3、然后修改指针，插入结点（p之后插入新结点是s） 删除操作：（1&lt;=i&lt;=n）1、先找到链表的第i-1个结点，用p指向。2、再用指针s指向要被删除的结点（p的下一个结点）3、然后修改指针，删除s所指向的结点。4、最后释放s所指向结点的空间。 //以下内容是从北航参考书目中摘录，可不看。 一、对线性表实施的基本操作有：1.置线性表为空表，该操作将会生成一个空表。2.检测一个线性表是否为空表，若是则返回真，不是则返回假。3.求线性表的长度，返回一个非负的整数，即线性表中数据元素的个数。4.检索线性表中第i个元素，操作的结果为一个数据元素ai或者ai的存储位置。5.根据数据元素的某个数据项的值求该数据元素在线性表中的位置，也称数据元素定位，操作的结果为一个非负的整数。6.在线性表的第i个位置插入一个新的数据元素，线性表的长度+1，这种操作只有在1&lt;=i&lt;=n+1时才有意义，即元素可以插在线性表的头尾和中间，而不能插在别的位置。7.在线性表的第i个位置存入一个新的值，不改变线性表长度，即覆盖掉原来这个位置的值。8.删除线性表中第i个数据元素，线性表长度-1，只有当1&lt;=i&lt;=n时才有意义，对空的线性表不能实行删除操作。即删除之前要进行检测，否则会出现下溢。9.删除线性表中重复出现的元素。10.对线性表中的元素按照某一个数据项值的大小做升序或降序排序。11.复制一个线性表，即产生一个与已有线性表相同的新的线性表。12.按照一定的规则，将两个或两个以上的线性表合并为一个线性表。13.按照一定的规则，将一个线性表分解为两个或者多个线性表。 二、顺序线性表的构造最简单的方法就是：用一组地址连续的存储单元来依次存储线性表的数据元素，这种存储结构称为：线性表的顺序存储结构。并称此时的线性表为顺序表。线性表中的所有元素具有相同的属性，属于同一个数据对象。 在长度为n的线性表A的第i个位置插入一个新的数据元素item.分为3步：1，将线性表的第i个数据元素到第n个数据元素之间的所有元素依次向后移动一个位置（共移动n-i+1个元素）2，将新的元素item插入到线性表的第i个位置3, 修改线性表的长度为n+1需要注意数据元素依次向后移动一个位置的方向，必须是从表的末尾位置开始后移，直到将第i个元素后移一个位置为止。对于表长为n的线性表，算法的时间复杂度为O（n）。 删除长度为n的线性表A的第i个数据元素。插入之前先要判断表是否为空，如果不空，还要测试被删除的元素的位置i是否合适，合适的删除位置应该是1&lt;=i&lt;=n。若以上步骤出现异常，则删除操作都会失败。若满足删除条件，则具体的步骤分为两步，首先将表的第i+1个数据元素至第n个数据元素（一共是n-i个元素）依次向前移动一个位置，然后修改线性表的长度为n-1即可。算法的平均时间复杂度为O（n），课本p24. 确定元素Item在长度为n的线性表A中的位置。该操作只需要从线性表的第1个元素开始，从前向后依次通过比较来确定给定元素item在表中的位置。如果在表中找到满足条件的数据元素，算法就返回被查到元素在表中的位置；否则算法返回信息-1.（该算法没有考虑表中出现多个满足条件的元素的情况）最好的情况下，时间复杂度为O（1），最坏的情况下和平均的时间复杂度的情况下复杂度为O（n）. 删除表中重复出现的元素算法的思想是：从线性表的第1个元素到最后一个元素为止，依次检查在某元素后面的元素中是否存在与之相同的元素，若存在，则删除后面的那个元素，并且及时修改表的长度。算法的时间复杂度为O（n^2） 对线性表中的元素进行排序排序：按照线性表中数据元素的值或者某个数据项值的大小排列数据元素，使之成为一个有序表。排序算法较多：比较排序，选择排序，归并排序，基数排序，希尔排序，冒泡排序，堆排序，快排，插入排序等等。 线性表的顺序存储结构的最大特点就是：逻辑上相邻的两个数据元素在物理位置上也相邻，故其优缺点也很明显。优点：构造原理简单，较直观，易理解。若已知每个数据元素所占的存储单元的个数，并且知道第1个数据元素的存储位置，则表中任意一个数据元素的位置可以通过一个简单的解析式计算出来。（可随机访问）对表中的所有的数据元素，既可以进行顺序访问，也可以进行随机访问，也就是说既可以从表的第一个元素开始逐步访问，也可以根据元素的位置随机的访问，并且访问任意一个数据元素的时间代价都相同。只需存放数据元素本身的信息，而无需其他额外空间开销，相对于链式存储结构，存储空间开销小。缺点：线性表的顺序存储缺陷：需要事先分配存储空间,还得按照最大需求来考虑,造成了空间的浪费。导致一些基本的操作效率降低。比如删除和插入，都要移动元素。需要一片连续的存储单元作为线性表的存储空间。存储空间的分配需要事先进行，使得应该分配的存储空间大小不易估计，尤其在线性表长度变化较大的时候，必须按照可能的最大空间需求量分配，估计过大，容易造成分配的存储空间不能得到有效的利用；估计过小，空间容量的扩充通常比较困难。进行插入或者删除操作时，需要对删除或插入位置后面的所有数据元素逐个进行移动，操作的时间效率低，尤其当表比较长，且插入或删除点的位置靠前时，更是如此。 因此顺序表比较适合于线性表的长度不经常发生变化，或者只需要在顺序存储设备上做批处理的场合。 链式存储结构不要求逻辑上相邻的元素在物理位置上也相邻，仅通过指正来映射数据元素之间的逻辑关系，因此，它没有顺序存储结构中的某些不足，但同时也失去了顺序存储结构的可以随机存取的优点。链式存储结构不仅可以存储线性表还可以用来存储各种非线性的数据结构：树和图等。2.3.1线性表的链式存储结构是用一组地址任意的存储单元（可以连续也可以不连续）来依次存储线性表中的各个数据元素。链结点：data+link对于每一个数据元素而言，除了需要存储元素自身的数据信息之外，，还需要存储一个指示其直接后继元素位置的信息，这两部分组成了一个数据元素的存储结构，称之为一个链结点，链结点：两部分：1，用于存储自身信息的域称为数据域，用符号data表示。存储一个数据元素逻辑上的直接后继元素的存储位置的域称为指正域，用符号link表示。由于线性表的最后一个元素没有后继元素，故相应链结点的指针域存放”空（NULL）”,作图时可用符号^（大于符号开口向下）表示。由于链表中每一个结点中除了数据域以外仅设置了一个指针域，故称这样的链表为线性链表或单链表。整个线性链表由一个成为外指针的变量（也称为头结点指针，该指针变量不妨取名为list）来指出，它标明了线性链表的首地址，称为线性链表的入口地址，当链表为空的时候（list为NULL），这样线性表由该指针唯一确定。因为链表中的任意结点的存储地址都可以通过了从list开始，经过对链表的遍历操作得到，链表中的各个链结点所占用的存储单元不要求连续，但是每一个链结点内部占用的一系列存储单元则必须连续。所谓的一个链结点的地址是指该链结点占用的一片连续的存储单元的第一个单元的地址。逻辑相邻的两个数据元素在物理位置不一定相邻，因此这种结构也称为非顺序映像，或者链式映像。产生链结点的途径一般有两种：1调用系统中已有的动态存储分配过程或函数，（如c语言中malloc函数）由系统动态分配连接点的空间，2是利用程序中已经声明的数组的数组元素产生链结点，前一种方式叫动态链表，后一种叫静态链表，该书主要讨论动态链表，简称链表。P-&gt;data表示由p所指的链结点的数据域信息，否则，表示由p所指的那个链结点的数据域。P-&gt;link表示由p所指的链结点的指针域信息（指针域的内容），也就是p所指的链结点的下一个链结点的存储地址；否则表示由p所指的那个链结点的指针域（位置）对于P-&gt;link-&gt;data，单p-&gt;link不为NULL时，表示p所指的链结点的下一个链结点的数据域信息。因此当线性表采用线性链表结构时，要想取得链表中的某个元素，就必须从链表的第一个链结点出发进行查找，可见线性链表是一种非随机存取的存储结构。在线性链表中插入或删除一个结点时，不需要移动元素，只需要修改前后两个指针的指向位置就可以了，在已知链表中结点的插入或者删除位置明确的情况下，插入一个结点或者删除一个结点时，仅需要修改指针而不需要移动元素，这与顺序表是完全不同的。 线性链表的基本算法：线性链表一般不具有预先设置好的存储空间以备新的链结点使用.当有新的数据元素加入线性表时,需要临时从一个被称为存储库的机构中取得一个空的结点空间,填入必要的信息,然后将其插入到线性链表中。这个存储库并非为某一个链结点所专用，当任何链表操作需要新的链结点时都可以从中获取链结点空间（只要还有可用的存储空间），一旦某个链结点不再被使用时，可以将其送还到该存储库，该操作称为：存储释放或者回收。如果假设p是一个指向LinkList类型的指针变量，则从存储库中取得一个新的链结点空间是通过执行赋值语句p=(LinkList)malloc(sizeof(LNode))中的调用存储分配库函数malloc得到。该语句的作用是malloc生成一个LinkList类型的链结点，同时将其赋值给p，当对表进行的主要操作为插入和删除时，链式存储结构时线性表的首选的存储结构。关于线性链表的几种常用算法： 1建立一个线性链表2求线性链表的长度3测试其是否为空表4确定元素item在表中的位置5在非空线性链表的第1个链结点前插入一个数据信息为item的链结点6在非空线性链表的末尾插入一个数据信息为item的链结点7在线性链表中由指针q指出的链结点后面插入一个数据信息为item的链结点8在线性链表中第i个链结点后面插入一个数据信息为item的链结点9在按值有序链接的链表中插入一个数据信息为item的链结点10从非空线性链表中删除q所指的链结点11销毁一个线性链表12删除线性链表中数据域值为item的所有链结点13逆转一个线性链表14将两个非空线性链表连接成一个线性链表15将两个按值有序链接的非空线性链表合并为一个按值有序链接的线性链表16复制一个线性链表17利用线性链表进行数据排序 循环链表：链表中最后那个链结点的指针域不再存放Null，而是指向链表的第一个链结点，整个链表形成一个环。有时候为了解决问题的方便，可以在链表中第一个链结点的前面设置一个特殊结点，称之为头结点。头结点的构造与链表中其他链结点的构造相同，但数据域可以不存储信息。也可以存放一些诸如线性表长度的信息；指针域存放线性表第一个数据元素对应的链结点的位置。如果线性表为空，相应的循环链表此时并不为空链表，其还有一个头结点，其指针域指向头结点自己。 双向链表（双链表）：是指链表的每一个链结点中除了数据域以外设置的两个指针域，一个指向结点的直接前驱结点，另一个指向结点的后继结点。如下所示：Link data rlink其中link域指向直接前驱结点（称为左指针域），rlink域指向直接后继结点（成为右指针域），与线性链表类似，双向链表可以是非循环的，也可以是循环的。也可以根据要解决问题的需要在链表最前面（最左边）设置一个头结点， 双向链表的插入与删除算法：有关双向链表的一些操作，如求链表的长度，检索链表的第i个结点，仅涉及链表的一个方向，这些操作和线性链表的有关算法基本相同。但是由于其链结点的构造和单链表的不同，因此在双向链表中插入一个新的链结点或者删除双向链表中的一个链结点与在单链表中就不同了，因为需要同时修改两个方向的指针。 1在带有头结点的双向循环链表中第1个数据域内容为x的结点右边插入一个数据信息为item的新结点。（程序题）2在带有头结点的双向循环链表中删除第1个数据域内容为x的结点。（考程序题）3查找（程序题） 链表的应用：链式存储结构下的一元多项式相加构造头结点：头结点中存储着：系数+指数+link即为：coef exp link具体的操作过程参考书本p52 可参考文章:https://blog.csdn.net/Oceansidexue/article/details/79321059https://zhuanlan.zhihu.com/p/32450661]]></content>
      <categories>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-绪论]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[数据结构的三要素：逻辑结构、存储结构、运算。 逻辑结构是独立于存储结构的（数据的存储结构是逻辑结构在计算机上的映射，不能独立于逻辑结构）数据结构分为逻辑结构和物理结构，逻辑结构分为：线性结构、集合结构、树形结构和图形结构四大类。物理结构分为顺序存储结构和链式存储结构++a运算的效率高于a++。计算算法时间复杂度：Case 1: 循环主体中变量参与循环条件判断 （善用归纳法找规律）以一个例题来分析： void fun(int n) { int i = 1; while( i&lt;=n ) i = i*2;} Case 2:循环主体中变量与循环条件无关（1）非递归的方法（用累加的思想） for(i=n-1; i&gt;=2; i--) for(j=1; j&lt;=i-1; j++) if( A[j]&gt;A[j+1] ) A[j]与A[j+1]交换 算这个复杂度实质就是算A[j]和A[j+1]交换操作一共做了多少次（最坏情况下，所有相邻元素都逆序时，最后一行语句每次都会执行）可以用一个累加的式子来判断 ： 最外层循环是 n-1 ~ 2 , 第二层循环 1 ~ i-1 循环队列与数据的存储结构无关。 链式存储设计时，链表中的各个链结点占用的存储空间不要求连续，但是每一个链结点的内部占用的一系列存储单元必须连续。所谓一个链结点的地址是指该链结点占用的一片连续的存储单元的第1个单元的地址。抽象数据类型抽象数据类型（ADT）是指一个数学模型和定义在改操作上的一组操作，通常用（数据对象，数据关系，基本操作集）这样的三元组来表示。例题解析：一、单选1.数据结构是具有 的数据元素的集合。A.性质相同 B.特定关系 C.相同运算 D.数据项2.下列说法中，不正确的是 。A．数据元素是数据的基本单位 B.数据项是数据中不可分割的最小单位C. 数据可由若干个数据元素构成 D.数据项可由若干个数据元素构成3.数据的存储结构是指A．数组类型 B。指针类型 C.数据之间的逻辑关系 D.数据之间的物理关系4.在存储数据时，通常不仅要存储各数据元素之间的值，还要存储A.数据的处理方法 B 数据元素的类型 C数据之间的关系 D数据的存储方法5.在计算机的存储器中表示时，各元素物理地址和逻辑地址的相对顺序相同而且是连续的，称之为A逻辑结构 B 顺序存储结构 C链式存储结构 D 以上都对6下面的术语中，与数据的存储结构无关的是A循环队列 B栈 C散列表 D单链表7.下面术语中，与存储结构无关的是A 栈 B 顺序栈 C 线索二叉树 D 双链表8.下列各项中，属于逻辑结构的是A 哈希表 B有序表 C 单链表 D 顺序表9.一下数据结构中， 是非线性结构A 栈 B。队列 C完全二叉树 D堆10，对于数据结构，一下叙述中不正确的是A相同的逻辑结构，对应的存储结构也必相同B．数据结构由逻辑结构、存储结构和基本运算组成C 数据存储结构就是数据逻辑结构在存储器中的实现D 对数据基本运算的实现与存储结构有关11可以用 定义一个完整的数据结构。A．数据元素 B数据对象 C 数据关系 D抽象数据类型12.可以用 、数据关系和基本操作集定义一个完整的抽象数据类型A数据元素 B数据对象 C原子类型 D存储结构13链式存储设计时，结点内的存储单元A一定连续 B 一定不连续 C不一定连续 D部分连续，部分不连续二、综合应用 对于两种不同的数据结构，逻辑结构和物理结构一定不相同吗？ 试举一例，说明对相同的逻辑结构，同一种运算在不同的存储方式下实现，效率不同 答案：一、单选1-5 BDDCB 6-10 BABCA 11-13 DBA二、综合1.应该注意到，数据的运算也是数据结构的一个重要方面。 对于两种不同的数据结构，他们的逻辑结构和物理结构完全有可能相同。如二叉树和二叉排序树，二叉排序树可以用二叉树的逻辑表示喝存储方式，前者通常用来表示层次关系，而后者通常用于排序和查找。2.线性表既可以用顺序存储方式实现，也可以用链式存储方式实现。在顺序存储方式下，在线性表中插入和删除元素，平均移动近一半的元素，时间复杂度为O（n）;而在链式存储方式下，插入和删除元素的时间复杂度为O（1）。 关于算法：算法是对特定问题求解步骤的一种描述，它是指令的有限序列。算法的五个性质：确定性、有穷性、可行性、输入和输出。通常衡量一个”好”算法应考虑一下目标。 正确性：算法能够正确的解决问题。 可读性：算法应该有良好的可读性，以有助于人们理解。 健壮性：当输入非法数据时，能够适当的反应或处理，而不会产生莫名其妙的结果。 高效率和低存储：效率是指算法执行的时间。存储是指算法在执行过程中所需的最大存储空间。常见的渐进时间复杂度有：O(1)&lt;O(log2N)&lt; O(n) &lt;O(nlog2N) &lt; O(n2) &lt; O(n3)&lt; O(2n) &lt; O(n!) &lt; O(nn)算法的空间复杂度 算法的空间复杂度是对一个算法在运行过程中临时占用的存储空间的大小的度量。空间复杂度和时间复杂度一样用O表示，S(n) =O(g(n))空间复杂度为O(1)的算法称为原地工作或就地工作算法。 例题：一、单选 不是算法的特性。A 可行性 B 长度有限 C 在规定时间内完成 D 确定性2.某算法的时间复杂度为O(n2),表明该算法的 。A问题规模是n2 B 执行时间等于n2C 执行时间与n2成正比 D 问题规模与n2成正比3一个算法的执行时间为T(n) = (3n2+2nlog2n+4n-7)/(10n),其时间复杂度为 。A．O(3n2) B O(2nlog2N) C. O(3n/10) D O(n)4.以下算法的说法中错误的是A算法原地工作的含义是指不需要任何额外的辅助空间。B 在相同的规模n下，复杂度O(n)的算法在时间上总是优于O(2n)C 所谓最坏时间复杂度是指最坏情况下估算算法执行时间的一个上界。D 同一个算法，实现语言的级别越高，执行效率越低5.求整数n的阶乘的算法如下，其时间复杂度是 。int fact(int n ){ if( n &lt;= 1) return 1;Else return nfact(n-1);}A O(log2N) BO(n) C O(nlog2N) D O(n2)6求解Hanoi问题时，若初始有5个盘，则移动圆盘的次数是A 7 B 15 C 31 D 57 以下算法的时间复杂度是 。Void fun(int n){Int i = 1;While(I &lt;= n)I =i2;}A .O(n) B O(n2) C O(nlog2N) D O(log2N)8 设n是描述问题规模的非负整数，下面程序片段的时间复杂度是X = 2;While (x &lt; n/2)X= 2X;A O(log2N) B O(n) C O(nlog2N) D O(n2)9 有以下算法，其时间复杂度是 。Void fun(int n){Int I,j,x= 0; For(I= 1; I &lt; n; i++) For(j= n; j &gt;= i+1; j–) X++;}A O(n) B O(nlog2N) C O(n2) D O(n3)10.有以下算法，其时间复杂度为 。Void fun(int n){ int p = 1,d = n, f = n;While(d &gt; 0){ If(d % 2 == 0) p = p f; Else f= ff; d = d/2;}A O(l) B O(log2N) CO(n) D O(nlog2N)11 有以下算法，其时间复杂度为 .Void fun(int n){IntI = 0;While(iiI&lt;= n)I++;}A O(n) B O(nlog2N) C O(3次根号n) D O(根号n)12 以下算法中加下划线语句的执行次数为 。Int m = 0, I,j;For(I = 1; I &lt;= n; i++)For(j= 1; j &lt;= 2I; j++) M++;A n(n+1) B.n C.n+1 D.n2 二、综合 以下算法的时间复杂度为多少？Int fun(int n ){Int I,k;For(I = 1; I &lt;= n; i++)For(j = 1; j &lt;= n; j++){K = 1;While(k &lt;= n) k = 5*k;} 以下算法的时间复杂度为多少？Void Hanoi(intn,char x,char y,char z){If(n == 1)Printf(“move %c to %c \n”,x,z);Else{Hanoi(n-1,x,z,y);Printf(“move %c to %c \n”,x,z);Hanoi(n-1,y,x,z);}}答案：一、单选1-5 BCDAB 6-10 CDACB 11-12 CA二、综合 基本语句为 k = 5*k,设其时间为T(n)对于每循环一次，改语句的执行次数为m,有：5m &lt; n ，即m &lt;=log5nT(n) = mn2 = n2log5N = O(n2log5N) T(n) = 2T(n-1) +1 = 2(2(T(n-2)+1)+1= 22T(n-2)+1+2=2n-1T(1)+1+21+22+…+2n-2= 2n-1+2n-1-1= 2n-1 = O(2n)]]></content>
      <categories>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-内排序]]></title>
    <url>%2F2018%2F10%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%86%85%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[国庆放假，图书馆不开门，更新几篇文章。先从数据结构的内排序说起(大纲要求的几种排序)。 直接插入排序直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成： 第一层循环：遍历待比较的所有数组元素第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。如果：selected &gt; ordered，那么将二者交换代码实现 代码def insert_sort(L): #遍历数组中的所有元素，其中0号索引元素默认已排序，因此从1开始 for x in range(1,len(L)): #将该元素与已排序好的前序数组依次比较，如果该元素小，则交换 #range(x-1,-1,-1):从x-1倒序循环到0 for i in range(x-1,-1,-1): #判断：如果符合条件则交换 if L[i] &gt; L[i+1]: temp = L[i+1] L[i+1] = L[i] L[i] = temp 希尔排序希尔排序的算法思想：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成： 第一层循环：将gap依次折半，对序列进行分组，直到gap=1第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。 代码def insert_shell(L): #初始化gap值，此处利用序列长度的一般为其赋值 gap = (int)(len(L)/2) #第一层循环：依次改变gap值对列表进行分组 while (gap &gt;= 1): #下面：利用直接插入排序的思想对分组数据进行排序 #range(gap,len(L)):从gap开始 for x in range(gap,len(L)): #range(x-gap,-1,-gap):从x-gap开始与选定元素开始倒序比较，每个比较元素之间间隔gap for i in range(x-gap,-1,-gap): #如果该组当中两个元素满足交换条件，则进行交换 if L[i] &gt; L[i+gap]: temp = L[i+gap] L[i+gap] = L[i] L[i] =temp #while循环条件折半 gap = (int)(gap/2) 简单选择排序简单选择排序的基本思想：比较+交换。从待排序序列中，找到关键字最小的元素；如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。因此我们可以发现，简单选择排序也是通过两层循环实现。第一层循环：依次遍历序列当中的每一个元素第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。 代码def select_sort(L): 依次遍历序列中的每一个元素 for x in range(0,len(L)): 将当前位置的元素定义此轮循环当中的最小值 minimum = L[x] 将该元素与剩下的元素依次比较寻找最小元素 for i in range(x+1,len(L)): if L[i] &lt; minimum: temp = L[i]; L[i] = minimum; minimum = temp 将比较后得到的真正的最小值赋值给当前位置 L[x] = minimum 堆排序堆的概念堆：本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。 基本思想：堆排序可以按照以下步骤来完成： 首先将序列构建称为大顶堆；（这样满足了大顶堆那条性质：位于根节点的元素一定是当前序列的最大值） 取出当前大顶堆的根节点，将其与序列末尾元素进行交换；（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质）对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质； 代码def LEFT(i): return 2*i + 1 def RIGHT(i): return 2*i + 2 L:待调整序列 length: 序列长度 i:需要调整的结点 def adjust_max_heap(L,length,i): 定义一个int值保存当前序列最大值的下标 largest = i 执行循环操作：两个任务：1 寻找最大值的下标；2.最大值与父节点交换 while (1): 获得序列左右叶子节点的下标 left,right = LEFT(i),RIGHT(i) 当左叶子节点的下标小于序列长度 并且 左叶子节点的值大于父节点时，将左叶子节点的 下标赋值给largest if (left &lt; length) and (L[left] &gt; L[i]): largest = left print(&apos;左叶子节点&apos;) else: largest = i 当右叶子节点的下标小于序列长度 并且 右叶子节点的值大于父节点时，将右叶子节点 的下标值赋值给largest if (right &lt; length) and (L[right] &gt; L[largest]): largest = right print(&apos;右叶子节点&apos;) 如果largest不等于i 说明当前的父节点不是最大值，需要交换值 if (largest != i): temp = L[i] L[i] = L[largest] L[largest] = temp i = largest print(largest) continue else: break 建立大顶堆 def build_max_heap(L): length = len(L) for x in range((int)((length-1)/2),-1,-1): adjust_max_heap(L,length,x) def heap_sort(L): 先建立大顶堆，保证最大值位于根节点；并且父节点的值大于叶子结点 build_max_heap(L) i：当前堆中序列的长度.初始化为序列的长度 i = len(L) 执行循环：1. 每次取出堆顶元素置于序列的最后(len-1,len-2,len-3...) 2. 调整堆，使其继续满足大顶堆的性质，注意实时修改堆中序列的长度 while (i &gt; 0): temp = L[i-1] L[i-1] = L[0] L[0] = temp 堆中序列长度减1 i = i-1 调整大顶堆 adjust_max_heap(L,i,0) 冒泡排序冒泡排序是最简单的一种排序。冒泡排序思路比较简单： 将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；（ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）对序列当中剩下的n-1个元素再次执行步骤1。对于长度为n的序列，一共需要执行n-1轮比较（利用while循环可以减少执行次数） 代码def bubble_sort(L): length = len(L) 序列长度为length，需要执行length-1轮交换 for x in range(1,length): 对于每一轮交换，都将序列当中的左右元素进行比较 每轮交换当中，由于序列最后的元素一定是最大的，因此每轮循环到序列未排序的位置即 可 for i in range(0,length-x): if L[i] &gt; L[i+1]: temp = L[i] L[i] = L[i+1] L[i+1] = temp 快速排序快速排序的基本思想：挖坑填数+分治法从序列当中选择一个基准数(pivot)在这里我们选择序列当中第一个数最为基准数将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧重复步骤1.2，直到所有子集当中只有一个元素为止。用伪代码描述如下：1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中 代码：L：待排序的序列；start排序的开始index,end序列末尾的index 对于长度为length的序列：start = 0;end = length-1 def quick_sort(L,start,end): if start &lt; end: i , j , pivot = start , end , L[start] while i &lt; j: 从右开始向左寻找第一个小于pivot的值 while (i &lt; j) and (L[j] &gt;= pivot): j = j-1 将小于pivot的值移到左边 if (i &lt; j): L[i] = L[j] i = i+1 从左开始向右寻找第一个大于pivot的值 while (i &lt; j) and (L[i] &lt; pivot): i = i+1 将大于pivot的值移到右边 if (i &lt; j): L[j] = L[i] j = j-1 循环结束后，说明 i=j，此时左边的值全都小于pivot,右边的值全都大于pivot pivot的位置移动正确，那么此时只需对左右两侧的序列调用此函数进一步排序即可 递归调用函数：依次对左侧序列：从0 ~ i-1//右侧序列：从i+1 ~ end L[i] = pivot 左侧序列继续排序 quick_sort(L,start,i-1) 右侧序列继续排序 quick_sort(L,i+1,end)]]></content>
      <categories>
        <category>考研</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动互联网十年]]></title>
    <url>%2F2018%2F10%2F01%2F%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%81%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[移动互联网十年12011年8月16日，北京798艺术中心。台上，雷军每公布一项技术参数，台下就传来一阵几乎要掀翻屋顶的声浪。一位记者问：“这都是哪请来的托，太敬业了！”工作人员只得实话实说：“都是自己来的，我们也没想到。”这一幕，像极了4年前乔布斯在旧金山。“手机键盘、触控笔？谁要这些玩意儿呢？”在莫斯康尼会议中心举行的第一代iPhone发布会上，乔布斯向全世界宣布：苹果要重新发明手机！这引来了台下的阵阵欢呼，但当时的大多数人应该都想不到，当天这款产品的发布，竟然很快就打败了整个行业。iPhone的发布，并没有引起传统手机巨头特别的重视，却给了雷军极大的震撼。因为与传统“能上网的手机”相比，iPhone是“能打电话的智能终端”，这是质的区别。而紧接着Android的发布，则给了雷军更大的震撼。这让雷军开始思索，互联网之后的下一个热点会在哪里？但此时的雷军，正带领着金山做上市前的最后冲刺。从22到38岁，从6号员工到CEO，雷军为金山工作了16年。其实不仅仅是雷军，在中国的南方城市珠海，魅族创始人黄章也注意到了这款与众不同的手机。过去的4年，黄章带领魅族成为了国内最好的MP3品牌之一，但黄章却觉得，MP3已经看不到发展方向了，他们站在山顶正无路可走。而此时iPhone的发布，则让他一下找到了方向，黄章决定转型做手机。这与乔布斯最初做iPhone的初衷有些相似，2005年iPod的销量暴涨，但是乔布斯却愈发有些担忧，他总担心有什么会抢了他们的饭碗，想来想去，他觉得这个设备可能会是手机。他的担心不无道理，因为当时的手机都开始配备摄像头，这直接导致了数码相机市场的急剧萎缩，而如果在手机中内置音乐播放器，那用户就没必要买iPod了。不过，苹果最初并没有选择自己做手机，而是选择了与摩托罗拉合作，在其中内置iPod。但乔布斯实在无法忍受这款合作机型丑陋的外观以及混乱的操作方式，终于在一次产品会议上，他忍无可忍：“我受够了和这些愚蠢的公司打交道，我们自己来。”就这样，在历数了各种手机的“脑残”设计后，一款革命性的手机诞生了。iPhone与Android的横空出世，让雷军意识到，互联网还远远没有达到它应有的高度，移动互联网会创造更大的奇迹。他隐约感觉到，一个新的时代可能要来临了。2 出乎所有人意料的是，在带领金山成功上市2个月后，雷军选择了离开。 8年的上市准备，让他身心俱疲，那段时间他瘦的厉害，这个被认为是最勤奋的CEO，有点累了。这年夏天，在距离金山总部不远的清华大学南门外，华清嘉园的一栋民居里，iPhone刚发售，王兴就买来研究。 就在半年前，由于融资不顺，他刚刚卖掉了自己和同学一手创办的校内网，这个决定给他留下了巨大的遗憾。 不过王兴他们也是幸运的，因为对于大多数创业公司来讲，投入过时间、金钱、精力后，也不过是竹篮打水一场空，没有任何回报。 他决定重新做一件事情，但绝不是为了某一天再把它卖掉。 机会很快就来了，2007年3月，一个名为Twitter的网站在美国一炮而红，用户可以通过电脑、手机在Twitter上发布140个字符以内的消息。 当时还在百度的穆荣均把新闻链接发给了王兴，恰巧王兴也在看这个网站，他随即向穆荣均发出了邀请，希望一起来做一款中国版的Twitter。 王兴当时还在千橡，如果此时离开就会损失一大笔钱。但王兴说：“钱不重要，时间对我很重要。” 很多人创业是为了钱，但王兴不是，他对钱看的很淡，这可能与他的家庭有关。王兴父亲在福建当地开的水泥厂，年销售额就超过几亿元。由于家庭富裕，王兴是当地最早拥有计算机，也是最早接触互联网的人。 王兴的高中班主任认为王兴能有今天的成就，家庭经济实力起了很大作用，允许他可以不为谋生而读书，也允许他失败。 而王兴的父亲则将自己的成功归功于赌对了中国大时代的脉搏，或许父亲的敏锐嗅觉也传给了儿子，王兴几次都精准的踩到了互联网创业的浪潮。在经过了一次彻夜长谈之后，穆荣均终于下定决心。 就这样，在华清嘉园的一栋民居里，王兴开始了第二次创业，并为这个类似Twitter的网站取名“饭否”，为此他们翻了一星期的字典。 华清嘉园被誉为“民间硅谷”，这里曾先后走出了包括校内网、暴风影音、饭否、美团、酷讯、美丽说、酷我、快手、融360等一批知名互联网企业。 快手创始人宿华形容那是一段“楼上做无人机，楼下做团购”的日子。 宿华和王兴是校友，同样毕业于清华大学。2013年宿华在投资人的撮合下认识了程一笑，两人都很看好视频社交的未来，于是在华清嘉园一套三室一厅的房子里，做出了如今几亿“小镇青年”都在用的视频软件——快手。 3 在最开始的两年，饭否运营的不算成功。 因为大多数人都不知道140个字该发什么，所以用户增长一直缓慢，在此期间，王兴还尝试做了海内网。 直到2009年初，王兴又把饭否重新捡了起来，那段时间饭否用户突破了100万，增长势头很快，当年很多群体事件的第一消息源，都来自饭否。 当然，这也为饭否带来了麻烦。 很快，王兴的母亲在美国上网时发现，饭否停了。这让她非常担心，她说王兴从小要强，做事认真，这次对他的打击太大。 但王兴并没有过多的抱怨，他习惯于从自身找原因，他觉得是自己对这件事情认识不充分。因此后来在做美团的时候，他就很注意了。 不过即使在饭否被关停的时候，王兴的团队也没有散。只走了两个，其中一位长着一张娃娃脸的80后，是王兴的福建龙岩老乡。 这个年轻人，就是张一鸣。 张一鸣毕业于南开大学，读书时的张一鸣，不打牌、不玩游戏，这让他显得有些不合群。 但当大部分人还在用电脑聊天、打游戏的时候,张一鸣已经可以熟练使用搜索引擎了。在同学的印象中，他是个“技术型宅男”，但酷爱运动，尤其爱打羽毛球。张一鸣的第一份工作是在酷讯，当时酷讯想做下一代的搜索引擎，这让张一鸣很兴奋，虽然他也不知道该怎么做，但他很愿意去学。 遗憾的是，酷讯的两位创始人陈华和吴世春先后被资本赶出了公司，酷讯也因此在红极一时后迅速衰落，先是卖给了Expedia，后又被美团收购。 不过，酷讯在中国的互联网历史上却颇具传奇色彩，这家公司曾先后走出了包括张一鸣、陈华、吴世春等在内的30多位活跃的创业者。 虽然两次参与创业都失败了，但在酷讯和饭否的经历，却让张一鸣对信息分发形成了独到见解，也让他得到了酷讯投资人王琼的青睐。 饭否关闭后，张一鸣开始了自己的第一次独立创业，创办了九九房。 4 离开金山的这段时间，雷军在投资圈做的风生水起，先后投出了拉卡拉、凡客、YY等20多家公司。 但他总觉得自己缺少点什么，想来想去，他觉得自己缺少一家可以称得上伟大的企业。 雷军成名很早，他在金山担任总裁的时候，马化腾和丁磊还只是金山下面的站长。而如今腾讯已成长为中国市值最高的公司之一，网易也做的风生水起。 但上市后的金山，市值却只有主流互联网公司的零头，这让他开始反思。 18岁的时候，雷军曾经读过一本《硅谷之火》，这本书讲述的是比尔·盖茨和乔布斯等人通过创业改变世界的故事。 这给了雷军极大的触动，也彻底点燃了他的创业梦想，他希望自己有一天也能像乔布斯一样创办一家世界一流企业。 这部小说后来还被改编成了电影，电影传到中国后，也深深的影响了几名上海的学生。 2008年的一天晚上，在上海交大的研究生宿舍里，一位学生正在和舍友看这部改编的电影《硅谷传奇》，这激起了这位学生创业的想法。 天南地北的想了一通之后，方向没找到，反倒是几个人的肚子都饿了。但平时随手可见的外卖单，却怎么也找不到了。 这个研究生，就是张旭豪。 张旭豪出身于商业世家，他的祖父曾经是上海滩著名的纽扣大王。可能与家庭的熏陶有关，张旭豪的经营头脑似乎与生俱来。 2009年，张旭豪和同学每人凑了几万块钱，买了8辆电瓶车，一起创办了“饿了么”网上餐厅。 起初，由于招不到配送员，他们就自己送。当时还在读研的张旭豪，每天骑着电动车在校园内送餐，浑身上下也看不出985高校硕士的影子。 5 2008年，中国的互联网人口第一次超过了美国。 这年10月，第一部Android手机发布，雷军特意去香港买了一部。用完之后，雷军更加坚信，未来的移动互联网将会以手机为核心，而手机也将替代PC成为下一个中心。 其实在2006年的时候，雷军就预感手机上网将会是趋势，当他看到UC浏览器，能把一两百K的图片压缩成10K，便果断投资了UC，并且亲自担任董事长。 当然，也有人有不同意见。早在2004年，就有人跟李彦宏讲，一定要关注手机，关注移动搜索。 但李彦宏觉得，在手机上做搜索，不仅速度慢，而且还很贵，一个短信一毛钱，这个体验太糟糕了。他对这些建议说：“不行，我们不需要做这个东西。”2009年，雷军40岁生日这天，他和几个朋友一起喝酒。雷军感慨，“人是不能推着石头往山上走的，这样会很累，而且会被山上随时滚落的石头给打下去。要做的是，先爬到山顶，随便踢块石头下去。” 做了20多年的互联网创业，看了太多的起起落落，雷军开始明白，成功一定要顺势而为。以至于雷军后来成立自己的基金，也取名顺为，即顺势而为。 后来，他在微博上将这句话总结为“只要站在风口，猪也能飞起来”，这句话后来演变成了著名的风口理论。 而下一个风口，在雷军看来，就是智能手机。 6 由于没有做手机的经验，直到2009年夏天，魅族的第一款手机才正式发布。 这款被称为“山寨iPhone”的手机，引起了雷军极大的兴趣。 他托人找到了黄章，那段时间雷军频繁出入魅族，两人经常在黄章的办公室一边喝可乐，一边讨论手机，黄章甚至把手机设计草稿拿给雷军看。 据传闻，黄章将做手机的经验倾囊相授，雷军则把软件、互联网和公司运作的方法悉数告诉了黄章。 黄章说，雷军每次来他办公室，最想听的就是他如何在论坛上跟“魅友”互动，但黄章也承认，雷军如今已经把社会化营销做到了极致。 雷军最初想以投资人的身份进入，为此还将谷歌的林斌介绍给黄章，希望黄章能拿出5%的股份吸引林斌加盟。但这位只有初中学历的企业家，显然没有看懂资本以及股权分配的重要性。 黄章认为高薪分红都没问题，但股份免谈。雷军则认为，要给高管股份，否则很容易被人挖走。黄章说：“他们走了我自己也能做”。 后来黄章回忆说：“当初确实看不懂资本运作，利润分享只停留在勤劳致富的思路，在竞争激烈的今天，继续依靠有限的利润来奖励分配，对企业和员工都是输家。” 由于和黄章谈的不欢而散，2009年下半年，雷军开始筹备小米。 彼时的中国，山寨机横行，市场上除了高端机，就是山寨机，而在山寨和高端之间，缺少一个高性价比的品牌。 雷军正是瞄准了这个区间，他认为中国有十几亿的手机用户，哪怕只有10%，也是一个千亿级的市场。 7 2009年11月的一个晚上。 雷军和晨兴资本的刘芹打了12个小时的电话，这中间，雷军换了3块电池，刘芹换了3部手机。 放下电话，刘芹决定投资雷军。 刘芹是雷军的湖北老乡，两人相识很早，关系也很密切，两人曾共同投出了迅雷、UC、YY等项目。 不过，虽然有过多次创业的经历，但雷军从未涉足过硬件。因此，找人成了最大困难。 他用Excel列了很长一串名单，然后挨个去谈。他跟每个人介绍我是谁，做了什么事，想找什么人，能不能给个机会见面谈谈。 那段时间，他每天从早上谈到晚上一两点。 最终，他找来了谷歌的林斌、金山的黎万强、微软的黄江吉以及摩托罗拉的周光平等14个人。这些人，共同组成了小米的初创团队。 2010年4月6日，在离金山总部不远的银谷大厦807室，黎万强的父亲端来了一锅熬好的小米粥，几个创始人一人喝了一碗，小米就算成立了。 而之所以叫小米，是因为mi是mobile Internet（移动互联网）的缩写，其次mi还是mission impossible的缩写，意味着小米要完成不可能完成的任务。此外，雷军还希望用小米加步枪的精神去创业。但创业初期的雷军极其低调和保密，他先是低调的成立了公司，之后又以第三方的名义开发了MIUI系统，即使在招聘员工的时候，他也不说自己是真正的老板。 这与雷军之前在UC和YY的处理方式类似。直到2011年7月，在一次沟通会上，雷军才说，“我不仅是投资人，也是小米的创始人和CEO。” 大家这才恍然大悟。 8 不过，在2010年成立的不仅有小米，这一年的中国互联网，可以说是相当热闹。 这一年，谷歌宣布退出中国，百度因此成为了最大的受益者，而淘宝也替代B2B成为阿里新的增长点，腾讯则宣布QQ同时在线超1亿人。 二马一李1 自此，百度、阿里和腾讯分别掌握了互联网最重要的三个应用入口，成为新的三巨头，被称为BAT。 面对BAT的崛起，传统的三大门户则陷入了模式困境。网易放弃了正面战场，专注于网游；搜狐则多面出击，布局了输入法、视频以及网游；而新浪则模仿Twitter推出了新浪微博，并且很快就成了一款现象级产品。 此外，微信、美团、爱奇艺等也都在这一年相继成立。因此，这一年也被公认为是移动互联网的元年。而除此之外，这一年还有件事不能不提。 2010年初，腾讯开始对QQ医生（后升级为QQ管家）进行强势推广，功能与360的安全卫士十分相似。 这引起了周鸿祎的警惕与不安，此后双方你来我往针锋相对，事态不断升级，最后发展到互发弹窗指责。 在周鸿祎看来，腾讯完全是模仿和抄袭。他曾经表示，“互联网的创业者，一定会遇到三个无法回避的问题：生、死、腾讯。” 事实上在2010年之前，腾讯的业务已经涵盖了包括即时通信、门户、游戏、搜索、电商以及浏览器、输入法、支付等几乎所有的领域。 作为模仿者，腾讯总是能在最恰当的时间出来“搅局”，甚至由于“一直在模仿从来不创新”而被嘲讽为“全民公敌”。以至于今天的投资人往往会问创业者一句话：“如果巨头做这个事情，你们如何保证不被干掉？” 而这种压抑已久的不满，终于在一篇《“狗日的”腾讯》之后，让腾讯成为了众矢之的。 在腾讯紧急召开的总裁办公会上，所有人都面色沉重，每人面前都摆放着一份复印件，在长达15分钟的时间里，没有人发言。最后还是马化腾先开口，他喃喃自语：“他们怎么可以骂人？” 然而故事还没有结束，等待腾讯的，是一场更大的危机。 2010年10月29日，这一天是马化腾39岁生日，当天360上线了扣扣保镖，这对于腾讯来讲无疑是“釜底抽薪”。腾讯几乎所有的高管都集中在总部的大会议室，但不是为了过生日，这里已经成了临时“作战室”，气氛紧张。 几天后，腾讯发布了著名的“艰难的决定”，要求用户二选一。 虽然事件很快就得到了平息，但舆论却几乎一边倒的站在了360一边，这让马化腾开始反思：“过去，我们总在思考什么是对的。但现在，我们要更多地想一想什么是能被认同的。” 这场危机的出现，不仅改变了腾讯的战略，也改变了马化腾的性格。此后腾讯变得不再一定要复制，不再一定要将对方打死，转而开始开放平台、布局生态。 而3Q大战，也成了PC时代的最后一场争夺战。 随着这场大战的结束，也宣告了一个时代的终结，竞争者们纷纷转入移动互联网，一个新的时代开启了！ 9 就在3Q大战打的火热之际，一款基于手机通讯录实现免费短信聊天的软件Kik上线仅15天，用户就突破了100万。 这引起了雷军的注意，他认为这很有可能会成为占领移动互联网领域极佳的切入点，因此他决定模仿kik做一款即时通讯软件。 一个月后，米聊问世了。 在米聊发布后的一次聚餐中雷军说：“如果腾讯介入这个领域，那米聊的成功性将大大降低，腾讯给了我们3个月的时间。” 雷军的情报来自于腾讯深圳总部，但他没有注意到广州的一支小团队。就在Kik发布后不久，广州的一位程序员也注意到了这款软件。 一天晚上，他在看Kik类的软件时，产生了一个想法：移动互联网会产生一个新的IM，而这种新的IM很可能会对QQ造成很大威胁，有必要提前阻击潜在的对手。 想了一两个小时后，他给马化腾写了封邮件，建议腾讯做这一块业务，马化腾当即表示同意。 这个人，就是张小龙。 张小龙后来回忆说，其实当时只是脑子一热，突然搭错了一根神经，写了这封邮件，没想到很快便得到了回复和认可。 事实上，这并不是雷军和张小龙的第一次交集。 早在1997年，张小龙就靠一己之力写出了Foxmail，他也因此被认为是当时中国最好的程序员之一。 虽然Foxmail让张小龙有了很高的知名度，但由于软件本身是免费的，因此并没有给张小龙带来任何经济上的好处。而且由于用户越来越多，Foxmail的维护已经让他不堪重负。 直到1998年的一天，张小龙收到了一封邮件，谈的是Foxmail的漏洞，但让张小龙没想到的是，对方竟然是刚刚出任金山软件CEO的雷军。 张小龙和雷军同岁，两人同年到武汉上大学，一个在华工，一个在武大。但98年的雷军已经是中关村的风云人物，那一年，两人才29岁。 雷军问张小龙是否愿意把Foxmail卖给他，张小龙想了一下说15万。但事后负责具体谈判的人员却认为这款软件金山自己也能做，不值得收购。 因此，雷军和张小龙的第一次，就这样错过了。 10 因为没有商业模式，张小龙经常被周鸿祎批评。 那个时候，周鸿祎还是方正软件研发中心的一名副主任。他经人引荐找到了张小龙，两人偶尔还会一起去广州的巷子里买盗版碟。 周鸿祎认为Foxmail应该加广告，但张小龙不愿意，他生性孤独，不善言辞，就如同微信开机画面中那个孤独的背影。 所以每次争论都以张小龙的沉默结束，以至于微信后来成功后，周鸿祎很疑惑：“这样一个人怎么就做出微信了呢？” 但当时周围的朋友都觉得他可怜，甚至连当时的《人民日报》都发表文章称，认为张小龙只是个“悲剧人物”。 这让他在很长一段时间内，陷入了深深的迷茫。 不过有意思的是，就在《人民日报》为张小龙感到悲哀后不到一个月，Foxmail就以1200万元被博大收购，张小龙也被任命为博大首席技术官。5年后，Foxmail又被腾讯收购，张小龙和他的团队则一起加入了腾讯。 在腾讯，张小龙获得了极大的空间，他所在的广州研发中心负责QQ邮箱业务，被允许在腾讯总部之外自成一体。 而张小龙也不负重托，带领QQ邮箱从一个边缘产品，成为了国内使用人数最多的邮箱。 11 2010年11月，微信项目正式启动。 张小龙带领一支不到10人的小团队，在广州研发中心的一间小会议室里开始了中国版Kik的尝试。 最初的人员基本都来自QQ邮箱团队，还有一半是实习生，没有什么做手机客户端的经验，包括张小龙在内的所有人都不知道要把微信做成什么样。 但与此同时，米聊的用户增长却十分迅速，这让腾讯感到了危机。 不过微信当时面临的最大的威胁其实不是来自外部，而是来自内部。张小龙曾经坦言：“当时最想干掉微信的不是米聊，而是手机QQ。” 事实上，手机QQ的功能在当时已经十分强大，并且拥有庞大的用户群。因此腾讯内部始终存在争议，反对者认为一个公司没必要做两款类似的APP，甚至有人直接在公司高层会议上建议停掉张小龙的项目。 而且，当时腾讯内部至少有2个团队在做类微信的产品，张小龙的团队在各个方面都处于下风，因此集团大多数人都觉得他连内部这一关都过不了。 但是，马化腾还是给予了张小龙充分的信任。 其实，早在运营Foxmail时，张小龙就曾和马化腾有过交流。 有一次，张小龙突然收到一位用户的邮件，对方对Foxmail提出了一个疑问，他有些吃惊，这是一个非常细微的错误，很难察觉。这个人说他叫pony，在经营一个站点。 但直到2005年Foxmail被腾讯收购，马化腾请他聚餐，两人才第一次见面。终于，在米聊推出后一个多月，微信面世了。 虽然米聊只比微信早了一个月，但在互联网时代，一个月可以做的事情很多，一个月积累的用户也有可能成为胜负的关键。 而米聊在与微信的赛跑中，也确实表现出了强大的战斗力。但是随着用户激增，米聊基础薄弱的问题还是暴露了出来。米聊的服务器曾在一天内宕机5次，用户也开始频繁掉线。 转折出现在2011年7月。 当时，微信推出了“查看附近的人”，这个功能彻底扭转了战局，也让微信的日增用户迅速达到了10万以上。到了2012年3月，微信用户已经突破一亿。 这之后，虽然又出现了易信、来往等社交产品，但都没有对微信形成太大威胁。 最终，凭借着微信，腾讯拿到了移动互联网时代的“船票”。 12 有人问唐岩：你觉得什么会颠覆微信？唐岩心想，我要知道我不早干了。 2011年9月，刚被提升为网易总编辑的唐岩还是决定离职，在北京霞光里15号的一间民房里，创立了陌陌。 而在此之前，另一款社交产品饭否，由于久久看不到晨曦，王兴开始思考团队下一步该做什么？ 他们开了一个小小的年会，讨论假如这家公司明天就不存在了，大家会怎么样，这勾起了一些伤感，王兴哭了。 不过此时的王兴，已经对互联网有了深刻的认知，他很快就找到了新方向。 不久前，在太平洋另一端的芝加哥，推出了一款团购网站Groupon，名字由group（团体）和coupon（优惠券）组合而来。 在经过了一番研究后王兴认为，团购完全吻合了移动互联网与传统商业结合的新趋势，很有可能会成为下一个互联网浪潮。 因此，到2009年底的时候，他们决定做美团。 但是，从Groupon获得灵感的不止有王兴，美团上线后，又先后有窝窝团、拉手网、糯米网等多家团购网站上线。 从2010到2011年上半年，团购成为了互联网最火爆的创业领域，最高峰时曾达到5000多家，被称为“千团大战”。 这期间，投资机构疯狂投资，估值也高的离谱。而团购网站彼此间的竞争也可谓是惊心动魄、九死一生。 起初，美团并不具备优势，甚至连前三都进不了。而拉手网、窝窝团都比美团的融资更多，烧钱更狠，声势也更大。 而事实上，王兴此前也并没有管理大规模线下团队的经验，因为不论是校内还是饭否，都是典型的互联网公司，模式很轻，十几个人就可以做出拥有百万用户的网站。但团购不一样，需要庞大的线下团队。 美团创业的第一年，王兴每周的工作时间达到了一百多个小时。他楼下有家理发店，剪发需要一个小时，但为了省时间，他买来电动理发器，让妻子给自己剃了个光头，只花了20分钟。为了取得优势，竞争对手不仅展开了巨额补贴，而且疯狂挖人、打广告，为此不惜成本。有对手甚至成建制的将整个团队挖走，但有时候挖人的目的，并不是为了获取人才，只是单纯的为了搞乱对手。 除此之外，竞争对手的广告也是铺天盖地，甚至在美团上海办公室的电梯口，播放的都是对手的广告。而美团是唯一没有参与广告大战的一家，这让他们压力很大。因为在互联网行业，一旦落后，想反超很难。 不过王兴始终保持谨慎，此前的经验告诉他，一定要控制运营成本，要给自己留下充足的资金。而且美团内部当时判断，下半年将进入资本寒冬。 果然，资本市场的冬天很快就来了。 这年7月，成为团购市场的分水岭。这之后，竞争对手的钱逐渐烧光，融不到钱了，纷纷开始裁员。拉手网、窝窝团也相继折戟IPO，O2O泡沫破灭了。 而美团则在阿里的帮助下，实现了弯道超车，坐稳了行业第一。 13 就在团购大战打得火热之际，手机市场也悄然发生了深刻变革。 2010年，苹果发布了一款革命性的机型iPhone4，此后多款Android手机也陆续发布。iPhone和Android的出现，彻底激活了手机行业，也改变了手机行业的格局。 2011年8月，一代巨头摩托罗拉谢幕，两年后诺基亚的手机业务也被微软收购。诺基亚CEO忍不住感慨：“我们并没有做错什么，但不知道为什么输了？” 而与此同时，智能手机的销量却开始大幅上扬，2011年更是出现几何式增长。而此时国内的手机市场，除了“中华酷联”以及小米和魅族外，360、乐视、锤子也纷纷开始入局。 而国产手机最大的贡献就是推动了整个手机行业的进步，使得手机的性价比越来越高，迅速提高了中国智能手机的普及率。 随着智能手机的普及，越来越多的人开始通过手机上网，但此时国内的3G和WiFi尚不普及，很难满足用户的需求。 这一点与美国不同，在美国的许多城市，满城都是WiFi热点。但在中国即使到了今天，WiFi的覆盖也远远没有达到这个程度。 2011年，陈大年在盛大创新院提出了一个让WiFi共享的项目，这是一款基于分享从而实现免费上网的工具，比如今的共享经济还要早了几年。 陈大年为人低调，很少露面，这让外界对他知之甚少，或许他的另一个身份更知名一些，那就是陈天桥的弟弟。 1999年，陈大年与二哥陈天桥一起成立了盛大网络，并且凭借一款《热血传奇》的游戏，迅速成为了中国首富。那一年，陈大年只有26岁。但令陈大年颇为不解的是，这个名为WiFi万能钥匙的项目在很长一段时间内都招不到人。 没人对他的项目感兴趣，因为对于这些顶尖的程序员来说，上网太简单了，完全没必要再去做一个工具，而且他们也不会在意，每月几十块钱的流量费。 但是陈大年认为，对一些人来讲上网或许会改变命运，就如同20年前的自己。 陈大年小时候生活在农村，他清楚的记得，从他所在的村子去城市，要走一个小时才能看见一辆车。就是在这样遥远而艰辛的路程中，他深刻体会到了先进知识和技术的重要性。 1998年，北京和上海开始互联网试点，陈大年带着全家的户口本跑到上海苏州河旁边的通管局，在填写了无数张表格之后，终于拿到了上网资格。 但那个时候，网速只有2-3K每秒，而且很贵。每天上网两小时，可能就会花掉他父母一个月的工资。 因此在移动互联网时代，陈大年希望能有一款产品让更多人免费接入互联网，拉平这个“数字鸿沟”。 而事实上，陈大年的理想此时正在以另一种方式快速实现着。 从2011年开始，在中国广袤的大地上，从北上广深到西部边陲，几乎所有的通信基站都开始新建3G设备，而华为和中兴是主要的设备提供商。 但行业内的人都知道，3G只不过是一个过渡技术，真正成熟的是4G。 事实上，3G基站还没有完全建设完毕，4G就来了。 4G的到来大大提升了手机上网的速度，理论上4G的下载速度可以达到100Mbps以上，比3G快了30-40倍。 这使得用户体验得到了极大提升，也为移动互联网彻底扫清了障碍。 从2012年起，用户开始从PC端快速向移动端转移，所有的互联网公司，都将目光集中在那个小小的屏幕上。 移动互联网时代正式开启。 14 2012年，中国的手机网民第一次超过了PC网民。 此时，APP开发成了最热门的领域，很多创业者希望，通过一款手机应用可以“改变世界”。 张一鸣敏锐的感知到了这一变化，他觉得机会来了。他认为在不远的将来，手机将成为人们获取信息的主要入口。 2012年3月，张一鸣辞去九九房CEO，成立了北京字节跳动科技有限公司。 但是今日头条并不是张一鸣推出的第一款产品，最初的三个月，这家公司上线了内涵段子、搞笑囧图、内涵漫画等多款应用。 没想到，内涵段子一经推出，就获得了很大成功。 当然，张一鸣可能也不会想到，6年后这个有着2亿“段友”的平台，将被迫关闭，而他一直极力推崇的算法至上，也给他带来了巨大的麻烦。 不过在当时，内涵段子的成功，则让张一鸣坚定了算法的价值。同年8月，一款基于机器学习的个性化信息推荐产品，今日头条正式上线。 虽然张一鸣是技术出身，但是在他看来传统新闻门户有着很大的局限性，就是无法实现个性化推荐，他想要实现的是让信息找人，而不是人找信息。 但在当时，几乎没人看好这个没有新闻经验的年轻人。而同样从移动互联网看到机会的还有程维。 这年夏天，刚从阿里离职的程维拿着10万元和同事王刚给的70万，做出了滴滴打车。 由于工作，程维经常要北京杭州两边跑，但当时的出行市场几乎被出租车垄断，他经常因为打不到车、拒载而误机。 恰好当时英国的打车应用Hailo刚拿到融资，这位不会开车的80后，就想到用打车软件来解决打车难的问题。 程维毕业于北京化工大学，戏剧性的是，与程维一同考入北京化工大学的，还有一个叫陈伟星的。但三个月后陈伟星选择了退学复读，第二年去了浙大，后来成了“快的打车”最初的创始人。 程维把他的想法告诉了周围的人，但所有人都说不靠谱，因为当时大部分出租车司机连智能手机都没有，更别说安装打车软件了。 但是程维认为，正是在市场基础不成熟的情况下，创业才有可能成功，等市场成熟就没机会了。 虽然程维做好了充分的心理准备，但滴滴的开局，还是异常艰难。程维回忆：有很多次，稍不小心，滴滴可能就死掉了。 15 2012年的一天，中关村e世界的一间办公室里。 一群出租车司机冲了上来，把一部智能手机摔在了地上。“骗子，你们这个滴滴软件一天十几个M，却没有一个订单。” M是什么？程维有点懵，搞了半天才明白，司机说的是流量。 当时，由于手机流量费用还较高，而APP每天又要消耗一定的流量，所以导致很多司机欠费停机。 无奈之下，程维只得跟司机承诺，“只要你们坚持使用，我就给你们补贴流量费。”他原本想向每位司机收取3元的装机费，没想到结果还得给司机补贴。 但尽管如此，装机者还是寥寥无几。 在滴滴成立的初期，程维和他的团队把北京的189家出租车公司都跑遍了，但只有昌平的一家小公司说愿意试试，这家公司总共才有70辆车。 经常有人问，“你们有没有交通委的红头文件？”“没有文件，你们也敢做？”有同事开始抱怨。 有一天，滴滴的平台上只有16位司机在线。 但程维没有气馁，他说起码有16个司机是相信我们的，我们不能让这16个人失望，不能让这16盏灯灭了。 没有订单，程维就去找人打车，他面试了一个人，工作就是打车。程维说：“我每天给你400块，你就绕三环打车，不要去昌平，资金有限，省着点花。” 但很快，程维和王刚凑的80万就花完了。 当时，程维跑遍了几乎所有的主流投资机构，但没有一家愿意投，滴滴眼看就要撑不下去了。 2012年11月，北京下了一场大雪，很多上班族打不到车，纷纷尝试滴滴打车，结果人们惊奇的发现，附近竟然有这么多空车。这一天，滴滴的订单首次突破1000单。 这引起了金沙江创投朱啸虎的注意，他主动找到程维，向滴滴投了200万美元，正是这笔投资，挽救了滴滴。 程维后来说：如果没有那场大雪，也许就没有今天的滴滴。 16 2012年的时候，一共有30多家打车软件，但是到了2013年，只剩下滴滴和快的两家。 2013年初，百度突然意识到，移动互联网时代似乎已经来了，但此时发力已经有些晚了。李彦宏说原以为把PC上的搜索搬到手机上是很简单的事，但没想到有那么多的坑需要填。 而与此同时，团购网站也几乎是所剩无几。 虽然O2O泡沫破灭了，但在王兴看来，O2O是对线上交易线下消费的统称，而团购只是其中的一种形态，因此未来可能会有更多符合用户体验的形态出现。 而事实上，美团内部也一直都在探索各种各样的O2O形态，悄悄上线，跑不通了，又悄悄关掉。 在做了很多分析之后，他们确定的第一个项目是做外卖。 美团的入局，让张旭豪显得有些急躁。 他和每一个城市经理开视频会议，刚开始还显得和颜悦色，但开着开着，张旭豪会突然拍着桌子咆哮：“市场份额才是第一！不要管成本！只要市场份额！” 虽然张旭豪表现得很强势，但美团的出现，还是让他感到了前所未有的压力。那个时候，千团大战刚刚结束，对于王兴的强悍，他心有余悸。 而且当时入局的不仅有美团，还有阿里的淘点点以及百度外卖，但淘点点雷声大雨点小，并没有影响到张旭豪。 淘点点入场后，张旭豪曾去找过张颖（经纬中国合伙人、饿了么B轮投资人），张颖说：“巨头来了，说明你们已经到风口了。” 其实美团外卖在上线之前，美团的王慧文曾去上海找过张旭豪，谈到了收购事宜。但张旭豪拒绝得很干脆，他还有敲钟的梦想。 但与美团相比，饿了么在资本、人才和技术方面都不占优势，因此在与美团的竞争中，渐渐处于下风。 那段时间，张旭豪经常把自己关在办公室里，冲着电话大喊大叫。他已经下定决心，要和美团死磕到底。 17 事实上，在中国的互联网创业历史上，类似的竞争屡次上演。 但没有一个行业比网约车的竞争更为惨烈。王兴曾经表示，虽然团购大战烧了很多钱，但跟网约车大战比起来，只是九牛一毛。 2014年的春天，杭州市民发现，仿佛一夜之间打不到车了，原因是滴滴和快的正在打补贴大战。 就连马云的母亲都忍不住吐槽，因为司机专挑有补贴的订单，至于不会用手机的老人，他们懒得理。而马云的父亲则说要不是看到有儿子公司参与，年轻人喜欢，早骂上门来了。 而补贴大战的背后，实际上是微信和支付宝的“支付大战”。 2013年11月，微信的开发人员在一次头脑风暴中，产生了一个创意。 在2014年的春晚上，这个将传统习俗与移动互联网结合在一起的创意，让腾讯一夜之间成了最重要的支付平台。 这个创意，就是微信红包。 微信红包的出现，让阿里受到了极大震动，马云则惊呼遭到了“珍珠港偷袭”。此后几年，双方一直围绕红包在春晚的舞台上展开争夺。 而微信红包的成功，也让程维受到了启发。当时滴滴刚接入微信支付，程维就想用红包做一次推广。他找到腾讯，想要几百万的推广预算，但没想到腾讯说：“几百万太少了，给你几千万。” 其实程维原本只是想做一次促销活动，但没想到迅速就引爆了市场。在阿里的支持下，快的也选择了跟进，并且宣布补贴永远比滴滴多1元。 由于补贴，滴滴的订单在两周时间内上涨了50倍，眼看40台服务器要撑不住了，程维连夜向马化腾求助。 当时的滴滴还在e世界，只有一间办公室，滴滴就在腾讯的办公室拼了七天七夜，期间没有人回家。出来的时候，团队中甚至有人出现了幻觉，大喊一声“地震了”。 不过就在滴滴和快的打的火热之际，Uber悄然进入了中国。而Uber的到来在一定程度上，也成了滴滴和快的合并的催化剂。 马云和程维都意识到，再这样打下去将会是两败俱伤，因此极力撮合两家合并。最终，在经过了疯狂的补贴大战后，滴滴与快的宣布合并。程维原以为滴滴和快的之间的竞争就是总决赛了，但没想到这只是亚洲区的小组赛。 2015年7月，Uber创始人卡兰尼克主动找上门，“要么接受Uber占股40%的投资，要么被Uber打败。”程维毫不犹豫：开战！程维说，那一刻他仿佛看到了1840年列强来侵略中国。 随后，滴滴策划了大反攻。他们把Uber比作章鱼，触角遍及全世界，但身体还在美国。王刚建议：要直取Uber的心脏。他觉得与其用1亿美元在中国市场做防御，不如拿1亿美元扔在美国。1亿美金扔在中国看都看不见，但扔在纽约，就会产生很关键的作用。 此后，滴滴先后投资了Uber在全球的多位对手，包括美国的Lyft，印度的Ola和东南亚的Grab，并且结成了共同的“反Uber联盟”。面对滴滴的强势反击，Uber很快就感到了压力，最终与滴滴达成了合作协议，退出了中国。 程维说：“滴滴是最没有安全感的公司，生在血海狼窝里面。在这个行业里，我们碰到了很多困难，2015年上半年仅在北京，我们的专车就被当成黑车抓了1500辆，一个城市就被罚了2000多万。我们在很多城市被宣布为非法，被约谈。” 程维说他每天感觉就像坐在一辆飞速行驶的车上，轮子都要飞出去了，但还要继续踩油门，每天都惊心动魄的。 18 与程维相比，张一鸣的今日头条则相对顺利。 虽然张一鸣一直笃定技术的价值，但是今日头条的发展速度还是远远超出了他的预期。 这极大的刺激了传统媒体和门户的神经。很快，今日头条就因“盗版”和“侵权”受到传统媒体的集体围攻，今日头条也被媒体嘲讽为“新闻的搬运工”。 张一鸣承认，今日头条确实在未告知的情况下抓取了媒体内容。但是张一鸣坚持认为，今日头条不是一家媒体公司，只是一个信息分发平台，就像搜索引擎。 他经常以拉里·佩奇和谢尔盖·布林在斯坦福校园创建谷歌为例，他说早期搜索引擎也被斥为盗版，今天大家肯定不会这么看。 事实上，这场新旧媒体之争，只不过是过去十多年媒体版权“战争”的延续。最终，头条通过取消转码，给原网站导流等方式，逐渐缓和了与媒体的关系。 此后，包括BAT在内的互联网巨头也看到了智能算法在移动新闻客户端的机会，陆续推出了一点资讯、天天快报、百家号等。 在移动互联网时代，内容创业者也迎来了春天。人生如果有四季，2014年也算得上是马云的春天。 2014年9月，阿里巴巴在纽交所上市，股票代码BABA。有人开玩笑说，以后让美国人都得叫阿里爸爸。 敲钟现场，由于粉丝众多，场面一度出现混乱，以至于CNBC的记者不得不学会了一句中国话：“请让一让。” 上市后的阿里，市值一度仅次于谷歌，成为全球第二大互联网公司，马云也因此成为了中国首富。不过马云并不是互联网行业诞生的第一位首富，在此之前，丁磊、陈天桥、李彦宏和马化腾都当过首富。 当被问起做首富的感觉，马云却说一点感觉也没有，他说他连他们小区的首富都不想当，他最快乐的日子是一个月拿90块人民币的时候。 而阿里的上市，还诞生了一位亚洲首富。 软银的孙正义先后投资了阿里8000万美元，在阿里上市后回报超过600亿美元。其实不仅是孙正义，南非传媒MIH前后投资腾讯总共约5000万美元，腾讯上市后，也获得了超过600亿美元的回报。 阿里和腾讯的投资回报率不仅创造了中国资本市场的神话，也让硅谷几十年来最成功的风险投资相形见绌。 但过去，这样的公司只会在美国出现，而如今，他们在中国诞生了。 19 但是资本神话的产生往往也意味着巨头的诞生。 随着体量越来越大，BAT已经将触角伸向了互联网的各个角落，很多领域的竞争最终都变成了巨头间的竞争。 2015年10月，美团和大众点评宣布合并。这次合并，不仅改变了O2O市场的格局，也使得美团站到了腾讯阵营。 美团和大众点评合并后，王兴和张旭豪见了很多次，探讨合并的可能性，但没有谈拢，因为张旭豪想自己掌控公司，王兴也是。 但美团和大众点评的合并，却使得阿里与美团的矛盾彻底爆发。 作为股东，阿里一直希望增加对美团的控制权。但王兴熟知资本的套路，他不愿被任何一方控股，因此一直坚称阿里只是财务投资，并且一直在积极引入其它资本抗衡阿里。 在王兴眼里，阿里是“霸道”的投资方，而在阿里眼中，王兴则是“不听话”的投资对象。 但与阿里糟糕的关系带来的结果就是，阿里不遗余力的扶持饿了么。 在阿里内部的高层会议上，蔡崇信力主发力口碑，并且表示要拿下饿了么以牵制美团。此后，阿里先后两次投资饿了么，金额超过22亿美元。 在阿里的支持下，饿了么有了与美团正面竞争的底气，并且在2017年8月收购了百度外卖。而曾经表示要不惜一切代价拿下O2O的百度，则选择了彻底放弃，转而布局AI。 不过，收购了百度外卖的饿了么，最终也没能逃过被收购的命运。2018年4月，阿里以95亿美金全资收购饿了么，同时也创下了中国互联网史上最大的一笔现金收购案。 这也是很多创业公司的归宿，如今BAT不论是从产品端还是投资端，都掌控了中国互联网的生态，成为创业者绕不开的三座大山。 即使是中国最好的VC，在投资金额上也远不如BAT，卖给BAT已经成为投资机构和创业者最佳的退出路径之一。 但就是在这样的情况下，却依然诞生了三家准巨头：今日头条、美团和滴滴，也被称为TMD。 TMD成长于BAT业务的边缘，成长迅速却又相对独立，因此也不可避免的成为了BAT的对手。 其实，在今日头条成立的第一年，张一鸣很害怕BAT们知道今日头条的存在，所以一直在躲，最后实在躲不了，只好直面迎战。 2016年，曾有传言称腾讯将入股今日头条。但一位员工告诉张一鸣，我加入头条不是为了当腾讯员工，张一鸣回答：“我也不是！” 张一鸣不想站队，在他看来如果站队就丧失了独立地位，给了阿里就都是淘宝链接，给了腾讯就都是游戏推广，给了百度就都是竞价广告。 他认为独立发展，价值会更大。如今，TMD已经分别占据了资讯、消费和出行的入口，也被认为是最有可能向BAT发起挑战的力量。 而移动互联网，则成为TMD崛起的重要机遇。 20 事实上，移动互联网的到来，不仅改变了“衣食住行”，也改变了人们沟通与记录生活的方式。 从2015年6月到2016年2月，快手的用户从1亿涨到了3亿，但用户到底是什么时候破亿的，宿华已经记不清了。 在此之前，快手一直游离于主流视线之外，没有做过任何推广。甚至在应用商店搜索“快手”最先跳出来的都是其他产品。 直到2016年6月，一篇关于快手的文章在朋友圈刷屏，才将快手推到了公众视野的中心。文章描写了一个行为荒诞怪异的魔幻乡村，这在当时引发了一些讨论，很多人认为快手上所呈现的内容是非主流，很low。 朋友把文章转给了宿华，面对评论宿华有点委屈，他不断滑动着手机，翻看着快手的页面，反复的说：“怎么low了，怎么low了？” 在宿华看来，快手上所呈现的，不是什么魔幻乡村，而是中国最广阔的现实，他与快手中的大多数人有着相同的生活经验，就像他曾经生活过的湘西小城。 不过，这段时间最火的不是快手，而是直播。 2015年3月，在北京西大望路的一栋二层小楼里。宿华的湖南老乡奉佑生从创业的500万元资金里面，拿出200万，从一家海外公司购买了实时美颜技术，做出了一款直播平台“映客”，并且喊出了“你丑你先睡，我美我直播”。 到了年底，他们的湖南老乡唐岩也决定转型做直播。在整个2015年，唐岩和他的陌陌都很难熬，在经历了上市前后的快速增长后，陌陌进入了低潮期，用户增长缓慢。 突然间直播大潮来了，这让唐岩抓住了机遇。凭借直播，陌陌迅速扭转了局势。那段时间，唐岩吃饭、打牌都端着个手机，经常对着手机东拉西扯。 得益于移动互联网和智能手机的普及以及美颜技术的提高，直播成为了这段时间的新风口。 2016年初，直播平台只有几十家，但到年底的时候已经超过1000家，堪比“千团大战”。这期间，各种直播平台层出不穷，YY、虎牙、斗鱼、花椒等相继入局。 但是仅仅过了一年，到了2017年初，由于同质化、监管等问题，直播行业就已经由热得发烫，变为了危机四伏。前后不过十几个月的时间，这是中国互联网过去从未有过的速度。 不过，这样的速度正逐渐成为常态。 21 2016年底的时候，人们惊奇的发现，马路上多了许多五颜六色的单车。而且随着单车品牌越来越多，有人调侃说颜色都快不够用了。 但是很快，单车的形势就急转直下，酷骑、小蓝等相继倒闭。 2018年4月3日晚，在摩拜总部召开的股东大会上，超过三分之二的股东同意了被收购的决议。 收购摩拜的，是王兴。 这些年，王兴不断扩展自己的边界。从团购到外卖，再到酒旅和出行，似乎从来不给自己设限。 而事实上，在收购摩拜之前，美团就已经在南京推出了美团打车。 美团打车上线的这一天，程维和王兴还在一起吃饭，但王兴只字未提，程维是过后看新闻才知道的。程维问王兴为什么要搞这件事，王兴说：“就是试试。” 原以为合并了Uber，网约车游戏已经结束了的程维，也不得不再一次直面竞争。作为回应，滴滴则上线了滴滴外卖。 当美团开始做打车，当滴滴开始做外卖，互联网公司的边界正变得越来越模糊。 但王兴认为，互联网典型的特征就是无边界。“传统行业可能很多井水不犯河水，甚至同样做地产，你做这个省，我做那个省。但互联网企业不管你干什么，中间这个边界都非常模糊，这就是这个行业的魅力。” 22 张一鸣也不给自己设立边界，这一点很像他的福建龙岩老乡。 虽然内涵段子关闭了，但是头条旗下的另一款产品抖音却火了。这让快手感到了威胁，今年春节后，在快手内部的会议上，越来越多的问题指向了抖音。 最近半年，快手的办公室里增加了二十几张外籍面孔，他们来自泰国、俄罗斯、韩国与印尼。从2017年开始，快手就一直在积极推进国际化。 但即使到了海外，快手也依然要面临和头条系产品的竞争。 早在2017年8月，头条旗下的火山小视频和抖音就以Hypstar和Tik Tok的名字走向了海外。去年11月，头条还收购了北美短视频社区Musical.ly。 如今，快手在俄罗斯、韩国占有优势，而抖音则在日本、泰国和越南等地先后登顶了App Store排行榜。 不过，随着越来越多的互联网企业出海，战线被拉出国界的不止有短视频。 目前，WiFi万能钥匙在全球的用户总数已经突破9亿，分布在全球223个国家和地区，并且在多个国家工具榜上排名首位。 今年5月，雷军在小米上市前的公开信中表示：小米已经在印度取得份额第一，并在15个国家名列前茅。 两个月后的7月9日，小米在香港上市。 这是雷军第二次到港交所敲钟，只是这一次雷军的身份变了，锣也比上次更大了。从去年下半年开始，国内的互联网公司就开始扎堆上市。先后有B站、虎牙、爱奇艺、拼多多、优信、映客等多家企业赴美、赴港上市。而美团也于9月20日正式在港交所挂牌，据传滴滴也希望在近期内完成上市。 这是继2000年、2010年之后，国内互联网公司的第三次上市潮。这其中，有相当一部分是移动互联网领域各个应用场景下的代表企业。 这些在移动互联网时代产生的创业公司，正集体走向成熟。 23 1995年的时候，马云说：“互联网将影响人们生活的方方面面。” 后来他觉得这句话他自己说没有分量，他就说是比尔·盖茨说的，但实际上就是他自己说的。 而今天，移动互联网确确实实已经影响到了人们生活的方方面面。 从2008年到2018年，超过十年的时间，也是中国移动互联网快速发展的十年。 在互联网时代，中国还只是模仿者和跟随者，与美国的差距也十分明显。而到了移动互联网时代，虽然美国依然领先，但中国正在快速崛起，已经逐渐能与美国进行抗衡。 起初，几乎每一家中国的互联网企业都是美国的“翻版”，但是原创往往很快就销声匿迹，而中国的“翻版”却都在日后找到了完全不同于原版的生存和盈利方式。 如今，当越来越多的企业走出国门，世界正越来越多的开始复制中国。今年5月，一场关于“5G投票”的争论，让5G走进了公众视野。这其中，中国企业正在从过去的参与者变为标准的制定者。 而5G的到来也将再一次大幅提升无线通信的速度，传输速度将达到4G的100倍，就连部分有线网络都将被无线通信所取代。 除此之外，5G还将容纳更多的设备，允许每个用户拥有多台联网设备。而且网络延迟小、出错概率低，将成为未来自动驾驶、物联网和智慧城市等应用场景得以实现的技术基础。 而目前，中国在5G方面，不论是网络规模，基站数量还是投资力度都处于领先地位。预计到2020年，中国就将实现5G的大规模商用。 曾经在一次采访中，王兴说：“我很幸运，生在中国，生在这个时代。如果早生30年，我能参与的事情完全不一样。如果不是生在中国，而是利比亚、刚果，那就不一样了。” 30年前，在四川创业卖鹌鹑蛋的刘永好，因为贷不到款，不得不变卖家中的手表、自行车等值钱的东西，才勉强凑了1000块钱。 而今天，在中国创业的难度比过去低了很多。“我不用贷款，我第一笔就有几百万美金的投资”，在一次访谈节目中张一鸣说道。 陈大年的父亲曾经问过他一个问题：你凭什么能赚那么多钱呢？陈大年没回答上来，父亲替他做了总结：“你要记住，你肯定是聪明并且努力的，但比这更重要的是，你和你哥哥遇到了一个千载难逢的机会！”十年，弹指一挥间。即使用尽笔墨，也讲不完所有的故事。 十年前，有人貌似在山顶，但正在走向下坡；十年后，有人看似在谷底，却蓄势待发。 人如此，事亦然。 许多的成功，都是从一件小事开始；许多的变革，都是在不动声色中发生。 十年前如此，十年后亦然。 https://mp.weixin.qq.com/s/3QY5tckRUT_zpB4Tf29Lbw101]]></content>
      <categories>
        <category>互联网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Happy birthday my girl]]></title>
    <url>%2F2018%2F07%2F31%2FHappy-birthday-my-girl%2F</url>
    <content type="text"><![CDATA[生日快乐！大狗子 春水初生，春林初夏，春风十里，不如你。愿有岁月可回首，且以深情共白头。 岁月静好，未来可期—未来的路上有你也有我，愿咱家狗子在新的一岁越来越美腻，然后咱俩一起奋斗，一起逛逛逛，吃吃吃呀。]]></content>
      <categories>
        <category>girl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[two years---a special day]]></title>
    <url>%2F2018%2F06%2F16%2Ftwo-years-a-special-day%2F</url>
    <content type="text"><![CDATA[在一起整整两年了，很不容易，也很珍惜，一切尽在不言中，未来的路有你也有我。爱你，我的大狗子。 17号咱俩去了户县的钟楼，楼观台，薰衣草庄园，还有周至水街……]]></content>
      <categories>
        <category>girl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[雨天.]]></title>
    <url>%2F2018%2F05%2F11%2F%E9%9B%A8%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[已经记不起这是第几次明知道要下雨，但是就是不想拿伞了，中午从宿舍出去的时候雨还很小，下午从图书馆的门一出来，一股妖风迎面吹来，好大的雨，没有感到一丝惊奇，慢慢的走回了宿舍，也没有跑。回到宿舍洗了澡换了衣服，拿上伞又出去了。 人越大越感到孤独，现在很多事不想和别人说，就算想说估计也没人想听吧。有时候自己深夜一个人站亦或是坐在阳台，看着深邃得看不见边的天空，偶尔一架飞机从头顶飞过…… 写到这眼泪突然调出来…改天在写…]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[袁家村之行]]></title>
    <url>%2F2018%2F04%2F29%2F%E8%A2%81%E5%AE%B6%E6%9D%91%E4%B9%8B%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[趁着五一假期，我和狗子去了袁家村一趟。 在去袁家村前一天晚上，我上网百度了一下关于袁家村的攻略，网上介绍袁家村的文章无一不给袁家村打上了：#民俗村、#关中印象体验地、#乡村旅游胜地等标签。这让我对袁家村产生了一些兴趣，玩了那么多地方，还没有去过有这种特色的。 五一假期的第一天，4.29号早上，早早的起床，在八点之前赶到了狗子那，然后一同坐上了166去往城南客运站，师大到城南客运站并不远，二十分钟左右就到了。在城南买过票后(去的比较早，没有排队就把票买到了，车票也很便宜，23/张)，就进了车站，城南客运站到袁家村的车大概四十分钟就发一趟，但是只要人坐满了，司机就会发车。我和狗子上车的时候，车已经快坐满了，因此在车上等了一小会就出发了。 袁家村比我想象中的遥远，坐了两个多小时的车才到，车上没开空调，也没窗户。狗子晕车，我也有点晕车。下车后，就到了所谓的一个车站，进站修整一下，车站就像民国时期的建筑，古朴没有多余的装饰。狗子进了厕所后出来，就说:”这里的厕所好像村里的….hhhhh”，这大概就是乡村旅游胜地的特色吧。 然后我和狗子就开始往袁家村逛啦，走过一条长约百米的笑道，来到一个像是城门的入口处，拿出手机赶紧拍一张。接着继续往里走，道路的脸庞开始出现卖各种东西的小摊。最多的是：卖帽子的、卖宠物的、还有套圈的、游戏设计的。还有卖菠萝的。天气有点热，伞不怎么管用，狗子挑了好半天才挑到一个差不多满意的帽子，能减轻一点太阳的炙烤。 走过长长的小摊路，就到了袁家村的“真正的入口”，在入口处，有个路标上面写着：回民街、小吃街、关中大观园。而整个袁家村差不多就由这三部分组成，先沿着面前的大观园走了进去，大观园主要是几个游乐场所。有个关中大地震，鬼屋…还有几个记不清了。在这里拍了几张照片就走了。 然后去了小吃街，小吃街个回民街连在一块的，各种常见的小吃在这里都能看到：大虾棒、鸭肠、炸土豆、豆腐、还有各种肉。我和狗子先是吃了一碗藕粉皮，味道不错就是太辣，狗子吃了几口后，吃不下了。我就把她那碗也吃了。然后我俩就穿梭在回民街和小吃街的各个巷道。中途进了一个鱼疗馆，可是担心会传染病菌，就没尝试。之后去了一个茶馆，茶馆占了很大一块地，摆满了桌子和凳子，有各种茶可以喝。还有按摩，不过看样子不怎么专业。我和狗子找了边上一个没人的桌子坐了下来，休整休整，歇了好一会儿，才再次出发，从书院路往回民街走的时候碰巧还遇见了狗子的同学。 然后我俩就打算返回入口处那，去那的游乐场玩玩，由于天气的原因，狗子选择了冰雪世界，一个极为正确的选择，进去之后我俩才发现里面的温度是真的爽，不过呆久了也受不了。里面可以坐着一个板子沿着一个轨道从上往下滑，我先体验呢一把，然后和狗子一起上。我和狗子坐在一块滑板上，我坐前面，狗子坐后面抱着我，那种感觉真好要是一直一直滑下去该多好，我和狗子来来回回的滑了五遍，hhhh。狗子还是意犹未尽，我也是意犹未尽，hhh,玩了项目，然后干啥，当然是拍照片的，狗子那么美，不拍几张图，怎么过意的去，唉。 帅气的功夫熊猫－我的狗子 还有潇洒的旋风踢 冰雪世界逛完后，我和狗子又玩了那个大轮子车…原谅我不知道那个车的名字，不过挺好玩的，就是不能漂移。 这时候，时间已经不早了，遂往车站方向走，走到途中，发现上一趟车已经走了，下一趟车还得等四十分钟，不如回去再逛一圈，顺便买袁家村的特产酸奶，于是我和狗子又沿着回民街逛了一圈，在某个巷道的分支里终于找到了卖酸奶的店，这家店很大，人很多，有好几种包装，我俩选了6瓶30的。付过钱接过酸奶，狗子就尝了起来，我也是,heihei。酸奶味道和普通的酸奶一个味，不过看着很新鲜。吃着比较放心。买到了心心念念的酸奶看看时间也不早了就开始返程了，在往回走的时候，吃了一份凉粉，凉粉做的不错，就是太酸，醋放太多了，不怎么习惯这种口味。 然后一路快走，到车站，等车，上车，买票，到城南，坐166，到师大，然后和我家狗子恋恋不舍的暂时性分别了。目送着狗子进了师大的校门，我等车回了学校。 总结一下：袁家村确实很民俗很有乡村特色，卖的东西和市场上几乎一个价，很实惠。不过逛完整个袁家村我和狗子都没觉得这是一个“景区”，而且还是一个4A级景区。大概我是山里的孩子，这种地方见多了，所以没觉得有啥特别的特点。不过最重要最重要的是，有我的狗子在身边，这比什么都好，有狗子在身边，就够了。此行无憾！（补充：我的拍照技术急需提高，打伞的技术急需提高，如果再拍不好狗子，撑不好伞，自我惩罚：剁叼）。]]></content>
      <categories>
        <category>旅行</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Http工作原理]]></title>
    <url>%2F2018%2F04%2F10%2FHttp%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 最近学了数据与网络通信，书里涉及到了部分TCP/IP协议和HTTP协议，对于HTTP协议只是很简单的提到了一下，故自己搜集资料，详细地了解了一下HTTP协议的工作原理，记录于此。 Http协议简介 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 计算机的相互通信协议 互联网的主要通信协议就是TCP/IP协议。两台计算机之间的通信是通过TCP/IP协议在因特网上进行的。TCP : Transmission Control Protocol 传输控制协议和IP：Internet Protocol 网际协议。IP：计算机之间的通信 IP协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个IP.用来在internet上标识这台计算机。 IP 负责在因特网上发送和接收数据包。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。 IP协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）。为了提供消息检验功能，直接在IP协议上设计了传输控制协议TCP.TCP : 应用程序之间的通信TCP确保数据包以正确的次序到达，并且尝试确认数据包的内容没有改变。TCP在IP地址之上引端口（port），它允许计算机通过网络提供各种服务。一些端口号为不同的服务保留，而且这些端口号是众所周知。 服务或者守护进程：在提供服务的机器上，有程序监听特定端口上的通信流。例如大多数电子邮件通信流出现在端口25上，用于wwww的HTTP通信流出现在80端口上。 当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路。TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。 TCP/IP 就是TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。 TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，IP 负责将包发送至接受者，传输过程要经IP路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。HTTP协议是基于TCP协议的，TIP/IP协议族共有五层，从下到上分别为：物理层、数据链路层、网络层、传输层、应用层，而HTTP就是应用层的协议。 HTTP请求响应模型HTTP由请求和响应构成，是一个标准的B/S模型（浏览器服务器模型），HTTP协议总是由浏览器端发起请求，服务器回送响应，而且HTTP是一个无状态的协议，即浏览器和服务器不需要建立持久的连接，这意味着当一个浏览器端向服务器端发出请求时，然后服务器返回一个响应，连接就断开，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。 HTTP的工作过程1.地址解析当浏览器请求一个页面时，其会从URL中分解出协议名、主机名、端口、对象路径等部分。 在这一步，需要域名系统DNS解析域名localhost.com,得到主机的IP地址。 2.封装HTTP请求数据包把第一步得到的结果结合自己的信息（浏览器自身的信息，比如型号，版本）封装成一个HTTP请求数据包。 3.封装成TCP包，建立TCP连接（TCP的三次握手）在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口。 4.客户机发送请求命令建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。 5.服务器响应服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 6.服务器关闭TCP连接一般情况下，一旦web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 客户机发起一次请求的时候：客户机会将请求封装成http数据包–&gt;封装成Tcp数据包–&gt;封装成Ip数据包—&gt;封装成数据帧—&gt;硬件将帧数据转换成bit流（二进制数据）–&gt;最后通过物理硬件（网卡芯片）发送到指定地点。服务器硬件首先收到bit流，然后转换成ip数据包。于是通过ip协议解析Ip数据包，然后又发现里面是tcp数据包，就通过tcp协议解析Tcp数据包，接着发现是http数据包通过http协议再解析http数据包得到数据。 ##HTTPS实现原理HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口号是443。SSL：安全套接层，是netscape公司设计的主要用于web的安全传输协议。这种协议在WEB上获得了广泛的应用。通过证书认证来确保客户端和网站服务器之间的通信数据是加密安全的。有两种基本的加解密算法类型：1）对称加密（symmetrcic encryption）：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES，RC5，3DES等；对称加密主要问题是共享秘钥，除你的计算机（客户端）知道另外一台计算机（服务器）的私钥秘钥，否则无法对通信流进行加密解密。解决这个问题的方案非对称秘钥。2）非对称加密：使用两个秘钥：公共秘钥和私有秘钥。私有秘钥由一方密码保存（一般是服务器保存），另一方任何人都可以获得公共秘钥。这种密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。 https通信的优点： 1）客户端产生的密钥只有客户端和服务器端能得到；2）加密的数据只有客户端和服务器端才能得到明文；3）客户端到服务端的通信是安全的。]]></content>
      <categories>
        <category>数据通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对最近几起互联网大事的思考]]></title>
    <url>%2F2018%2F04%2F06%2F%E6%9C%80%E8%BF%91%E5%87%A0%E8%B5%B7%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E4%BA%8B%E7%9A%84%E8%83%8C%E5%90%8E%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[前言昨晚看到一篇文章，读完后，感触颇深，与自己的一些想法不谋而合，遂记录下来。原文地址：https://36kr.com/p/5127520.html?from=timeline&amp;isappinstalled=0 原文内容 过去180天，发生了几个很有意思的大事。 今天，白富美的摩拜单车委身美团财团，中国最原创的创业故事，进入「垃圾时间」。 一个月前，滴滴吃掉快的后的网约车独家美食，在众声指责中，也迎来了最外行的对手，携程，美团，高德等等，开始抢食网约车市场。 再数月前，高达300亿美金估值的今日头条，展开了一系列横向并购，收购了抖音、小火山以及海外短视频社交，连腾讯递上来的示好，都十分爱答不理。 事情正在起变化，这是为什么？ 答案是，虽然每个孤立的合作并购案例背后，有着各自的独特逻辑，但是不可否认，都有一个共同的底层逻辑在主导着、约束着这些表面现象。 它们有一个巨大的背景公约数。那就是：互联网的流量故事已经接近到达上限，互联网企业估值，最擅长用来讲故事的内容不足了，一场互联网的大决战正在到来，赶在摧毁力量之前，大家必须合纵连横，抱团取暖。 这个问题，早在去年下半年就已经出现了，只不过还能硬撑。但是，随着今年整体市场上的资金流动性趋于紧张，恶化了互联网公司讲故事的环境，现在不得不快速进行主动或被动的应对。 下面，分两个原因，来谈谈为什么这件事情会发生。 这两个原因，一个与互联网公司估值的模式本质有关，另一个，则与资金层面的变化有关。 第一点，互联网估值的本质，有两个重要指标。其一，用户量的增长；其二，用户留存在平台上的使用时间。 这是几乎所有互联网企业估值的模型，也就是说罗胖子所说的时间的战争。 我们看到，随着中国多年的智能手机的普及运用，中国的互联网人口，已经基本上完成了跑马圈地，也诞生了很多个五亿级、十亿级用户的移动互联网平台。 相对于中国的总人口，互联网人口数量发展到这个程度，可以说用户量几乎到达上限，毕竟很多移动互联网平台都已经到三四五线城市下沉完毕。再发展下去，空间有限，你总不能不管老人小孩，都要把他迅速培养成互联网用户，这也不太现实，也不符合中国国情。 那么，流量故事讲完，现在就只能开始讲另外一个故事，用户使用平台的时长的故事。 要做到这一点，各大互联网巨头都要通过收购、联合等方式，来增加自身平台的业务应用场景，让客户留存在自己平台上的时间变长。 这就是巨头们最近买买买、或者幕后撮合大交易的底层逻辑。 第二个原因，就是资金的全面收紧。 互联网表面看起来是一个科技故事，其实是一个不折不扣的金融故事。互联网产业的背后，都是大量资本的烧钱。一个互联网公司短短两三年，从无到有，到估值数百亿元，在本质上，就是因为这个地方的资金过剩，而且缺乏很好的去处。 比如，在北京，大量的企业总部与国库所在地，各种资本泛滥，而制造业并不是鼓励发展的重点产业。在这种情况下，钱是不会进入北京制造业的，早期，钱还可以进入各种红木，古玩，收藏品市场，但是，这些领域本身容量很小，可以容纳的资金有限，如果容纳的钱过多，资产价格就会急剧暴涨，反而让投资变得更加不安全。 因此，大体量的资金，要么进入海洋一样的吸金大户房地产，要么就进入所谓的「可能性」生意，此处特指互联网。 有很多人会问，现在，医疗，养老，教育是非常大的痛点，人民群众苦之久矣，这些资金为什么不愿意进入医疗、养老这些刚性需求的行业呢？ 答案是，在这些领域，监管严格，阻力巨大，技术壁垒很强。 比如，拿医院为例，中国很多医院已经是半市场化的了，郑州第一附属医院，号称全亚洲最大的医院，一年可以做几万个手术，一天门诊量就可以达到2万人次，一年可以创造出160亿元的营业额。 在这个领域，既得利益群体太强大，专业门槛过高。同时，医院也有很多市场化的精英，一个个院长的脑子不要太好，而且，医保体系十分复杂，还有各种各样的价格管制，都构成了新资金进入的障碍。 资本不喜欢听这么复杂的故事，除非你有特别牛逼的背景。而互联网不一样，之前没有太多的利益群体，国有企业也不知道如何管理。所以才有成长空间，互联网是在夹缝中成长起来的，这也是中国民企崛起的共同之路。 我们拿杭州举个例子。2009年以后，浙商体系其实是走向衰弱的。他们不愿意再干实体经济，但是资金没有去处，那么，就在杭州搞互联网，以及炒房。 这是阿里系早年的强大融资来源。阿里之所以可以不断地烧钱，就因为阿里的故事他们听的明白，无非就是把浙江遍地都是的批发市场搬到网上去。至于阿里做大以后，它背后的融资来源就换成了各种外国的投资机构，上市之后就更国际化了。 杭州被认为是互联网经济很发达的城市标杆。那么，杭州大量的互联网创业的资金是从哪里来的呢？一群程序员就能有那么多钱？其实，很多浙江民资投资了这些程序员群体，是它们在阿里系的发展过程中发挥了巨大的作用。 如果光看人才，杭州的IT人才真的并不比中西部城市多太多，而西部三大城市的互联网程序员甚至比杭州更多。 这就矛盾了，为什么中西部没有很多互联网企业呢？道理很简单，因为没有钱烧，没有资本有胆量烧钱。 魔都上海为什么也没有全国知名的大互联网企业巨头呢？也很简单，因为大量的资金是本地国企与外企。 国企的投资纪律不允许烧钱，而且上海人民靠着黄浦江边的上交所，炒股票，放放贷款，就能够赚到很多快钱，为什么要去投资一个不确定性呢？ 互联网企业的崛起，需要大量社会民营资本的钱，国企的资金天生保守，害怕国有资产流失，天然不是创业资本的好金主。 帝都有北方各路权贵富豪，杭州则有大量的江浙富人，深圳更不用说了，各种风险资本与香港资本，后者便宜的融资与地下钱庄，在深圳的创业潮中发挥了极其关键的作用。 因此，互联网天生就是金融，而且更偏重于民营资本。这就是互联网背后的钱的逻辑。 当年，帝都很多互联网公司，后面就是当年的山西煤老板。当他们不炒房了，就开始进入互联网风险资金市场，比如，最近火起来的这些快手，抖音之类的各种视频与直播平台，背后都有这些煤二代烧钱，要不然这些企业到哪里去融资呢？ 做企业，首先就是融资。互联网企业天然具有风险性，银行是不会愿意投资的，因为按照它们传统的放贷纪律，必须要有抵押物。互联网除了团队与一个商业PPT，如何说服银行给自己放贷呢？ 所以，互联网创业就要找那种胆子大的钱，这种钱肯定不是那种有严肃财务纪律的企业的钱。一般国企不敢投的，万一亏没有了，领导要承担责任。 现在，很多互联网公司本身创造价值并不多，加上国家提倡实体经济，开始去杠杆，脱虚入实，这就是曲终人散、前景不妙的前夜。 只要信贷宽松，资金宽松，这些企业就会很嗨皮，懒得接受巨头们的收购与开价，很多创业公司甚至看不上BAT的钱包，自己觉得自己很牛逼。 但是，当信贷全面收紧的时候，很多资产管理计划与信托渠道都被堵死后，这些新平台的日子就很难过了。这个时候，他们才愿意接受卖身。你日子如果过的很不错，怎么会接受卖身呢？ 摩拜、OFO这些共享单车也是烧钱模式，就是看能烧出来一个什么样的平台，现在明显烧不动了。 因此，信贷收紧的结果，往往就是互联网企业的倒下，最近在美国股市，科技股也在下跌，背后就是因为美国的资金也在收紧了。每个国家都在追求脱虚向实。 浙江房企在发展的过程中也受益于江浙资金，尤其是拿地的钱，多来源于江浙财团。但是，当浙江互联网经济崛起后，很多资金转向了互联网，不再专供房地产，一些本地房企的融资压力就出来了。 这些现象的背后，都是互联互通的，底层逻辑就是钱的逻辑。 中国从去年开始进行强硬的去杠杆，就是要防止金融虚化，需要让资本流入能够创造现金流的行业。当信贷收紧，资金成本变高，互联网企业也都不淡定了，就得开始重组。我们最近目睹的这些合纵连横抱团取暖，与中国的金融去杠杆的时间表吻合，并不是一个很偶然的现象，它背后有深刻的商业逻辑在。 很多时候，创业热潮，不过是「便宜钱现象」而已，不要总觉得是这个国家的技术进步达到了某个爆发点，年轻人突然觉醒了一样。 当你把互联网不再当做一个基础设施行业，只当作一个像制造业、煤炭行业、房地产业一样的众多行业之一的时候，你对它就会有幻灭感，它一样要服从于经济规律，它不是高高在上的，也没有神迹，它也不是一个连上帝都宠幸的行业。在底层逻辑上，它也需要为金主制造价值，当资金环境发生变化的时候，它也一样必须在谈判桌上，该服软服软。 当资金大潮褪去，我们会看到越来越多的讲故事讲到听众寥寥的裸泳者。资金逻辑，不仅解释了过去这些发生在互联网领域的大事，也解释了过去很多房地产公司潮起潮落的命运变迁。 今年将是中国又一次高压的去杠杆开局之年，无论是土气的房地产开发商，还是油头粉面的互联网公司，在钱与金主面前，你们一律平等。 个人看法 当今的互联网创业，其发展壮大的过程就是不断烧钱的过程，没了钱的支持，再好的创意可能也会被潮流掩没，想起当初第一次看到ofo，一辆普通的单车，加上一把机械锁就敢拿来创业，没有任何技术含量，觉得这创始人脑子怕是有问题，这项目可能撑不过一个月，结果在不到三年的时间里，ofo融资数十亿美元，一举成为用户量最大的共享单车平台。同时期起来的比较牛的共享单车还有摩拜，现在已经成功卖身美团。纵观当今中国互联网格局，总体来说为：两超（AT）多强（BTMDJXW……）还有无数站队于AT两大公司的小公司。其中任何一个公司的崛起，都离不开烧钱。似乎有钱就可以成为巨头。滴滴成立至今不过6年，当年和快的uber大战，烧钱数百亿，最终快的被合并，uber中国被收购，滴滴成为网约车霸主；美团成立至今不过8年，当初为了占领市场份额，每年亏上百亿，一直持续了好几年，最终成为O2O领域的巨无霸：…… 几乎在每一个巨头成长的路上都能看到背后燃烧的大把大把的钞票。似乎谁烧的钱越多谁就是最后的老大…事实好像也的确如此，最近美团开启了部分城市的网约车项目，美团利用其高额的补贴和对司机承诺的报酬制度，才用了仅仅三天就拿下了上海网约车市场三分之一的市场份额，吓得滴滴半夜用打折优惠短信轰炸上海人民，这或许就是资本的力量——有钱就可以为所欲为。这样看当初自己眼光还是太狭隘了，在这个提倡创新创业的时代，创新的成功的没有多少，普通项目创业的成功倒是挺多，其本质还是资本的运作，在风口到来的时候，是个猪也能飞上天，趁着风停之前捞上一笔就溜了，这未尝不是创业者赚钱的一种好方法（摩拜卖身美团，创业仅仅三年的80后摩拜创始人胡玮炜套现超2亿$，这是一个普通人十八代也赚不到的数字）。不过看了看自己的口袋，还是默默去搬砖吧。]]></content>
      <categories>
        <category>互联网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python中print和return]]></title>
    <url>%2F2018%2F03%2F31%2Fpython%E4%B8%ADprint%E5%92%8Creturn%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[开始总是不怎么理解print的返回值，今天偶然看到一篇文章，豁然开朗,先贴上两段简单的代码：1：a=1;b=2def sum(a,b): c=a+b return cprint(sum(a,b)) 2:a=1;b=2def sum(a,b): c=a+b print(c)print(sum(a,b)) 输出结果是相同的都为：3这里代码1的结果是打印返回值得到的，而代码2的结果是在打印函数sum(a, b)时，sum (a, b)执行print c语句而得到的，其返回值是None，所以输出结果应为:3None返回值只有打印后才能得到，return的值是不会直接输出的。print(print(print(None)))的输出结果就是：NoneNoneNone]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[道歉]]></title>
    <url>%2F2018%2F03%2F26%2F%E9%81%93%E6%AD%89%2F</url>
    <content type="text"><![CDATA[先给狗子说声对不起。 今天我又惹狗子生气了，我很混账，明明约好的下午去逛街，但是我这个傻逼硬是先要去学习会，然后拉着狗子去教学楼找空教室，从一楼找到五楼也没找到一个合适的空教室，害得狗子腿都疼了，说到这里应该扇自己一个耳光，是我的一意孤行造成了这些后果。之后等狗子回我消息，不知道去找她，而等狗子来了以后还倔脾气不肯承认错误，把狗子都气哭了，我真是蠢到家了。 然后狗子拉我去吃饭，狗子走得比较快，而我在后面慢慢的跟着，不敢上前害怕狗子再生气，然后一直跟到了校门口，看着狗子出去了，之后我就在校门口等着狗子。想等着狗子吃完饭再和狗子好好认错，然后等了一会儿就看见狗子来了，提着一碗麻辣拌，(╯▽╰ )好香~~啊，狗子说给我买的，瞬间感觉好性福，结果狗子还没吃。我就喂狗子吃了两口，然后咱俩就一起吃了，我吃大白菜，狗子吃萝卜和别的，还是狗子好呀。 在这里我要认真的检讨一下自己，在狗子生气的时候不会哄她，有时候多等了一会狗子就没耐心了，我以前没有察觉到过，但是从今天起，我会彻底改掉这个。在狗子忙的时候，等着狗子的到来是一件很幸福的事。还有就是我到狗子的学校找狗子这件事，是我的不对，我也不该提这件事，当初和狗子在一起的时候就说过：狗子不来我的学校找我，但是我这个人有病，有时候还提起这件事，我该打，我做人起码得说话算话，不该提这个。包括一些别的，还有我的脾气什么的，都要彻底改掉，至少在狗子的面前，永远永远不会发作。这个也算我立下的字据。 之后吃完饭，和狗子逛到了邮电，一个熟悉的地方，在这里和狗子聊聊一些都感兴趣的，然后就到处逛逛，然后遇到了一件狗子很感兴趣的事—–两条小狗在做不可描述的事情，然后我俩在旁边不小心看见了…….过了一会就和狗子回学校了。 在回学校的路上，看见了喝奶茶的，狗子也想喝了，就和狗子坐小黄去了阳光苑买了柠檬水和奶茶，柠檬水很苦，没有蜜雪冰城的甜，差评，狗子喝的奶茶，味道还不错，然后狗子送我坐上了小黄，狗子就回了宿舍，在回去的路上，我回想了一下今天犯下的错，要是在古代，我这一个头都不够砍的，我惹了狗子生气，说了一些不该说的话，要是有的情侣，女生可能会让这个男的跪几天几夜的搓衣板，在路上我还把狗子的鞋踩了好几脚，这个我真不是故意的，可能是狗子对我的引力太大了，我总是不由自主的往狗子身边靠拢，也可能是心有灵犀吧，所以产生的万有引力大，把我吸向我的狗子，改天一定给狗子刷鞋，鞋咱得穿干净的，脏了就得洗呀。 再次给我的狗子说声对不起，对不起，吃一堑长一智，我得时刻记住狗子的话，不能再犯这种错误，在狗子不高兴的时候要学会哄狗子开心。给狗子捏肩捶背还有按摩……还有好多,电脑没电了先写到这，明天接着反思，]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sorry sorry my girl]]></title>
    <url>%2F2018%2F02%2F17%2FSorry-sorry-my-girl%2F</url>
    <content type="text"><![CDATA[寒假以来，没给狗子打过几次电话，好几次狗子给我打电话我都没接，我错了，都是我不好,我的小繁繁，这几天你把我的微信、QQ都删了，打电话刚打通就提示电话正在通话中，我想是把我屏蔽了，这都是我自己造成的，是我的错。你说我敷衍，可能我这几天有时候是有一点吧，但是我从心里从来没有想过要敷衍我的狗子。十一的时候，我把我俩出去玩的照片发到了朋友圈，当时评论的没多少人。但是没想到过年走亲戚的时候，好多亲戚都问我那么漂亮的女朋友咋没带回来，问你是哪的，让我早点带回家。他们都想见见。那时候我是多麽希望狗子你就在我的身边，能早点把你带回家给父母给亲人介绍，我能骄傲的对他们说，这是我女朋友。 除夕的那天晚上，突然接到狗子的电话，当时好激动，我的狗子终于肯和我说话了，可是没说几句就挂了，QQ也把我删了，然后的这几天我加狗子你总是不同意，每天心里都心欠欠的，看着你的头像、打开你的资料界面、翻看着你的照片发呆，每天早上醒来赶紧打开手机看看加你好友通过没，有没有给我发消息，看着你总是不回我，我的心里好伤心。就算你一直不通过不理我，我还是会找你的，狗子。我不会让你从我的身边溜走，我要抓住你的小辫子，可能是年纪大了，总是容易伤感，泪水在眼中打转，忍住不让掉下来，可是还是不争气的哭了，藏在被窝里瞧瞧的哭。 狗子早点回来，我会一直等你的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Happy Valentine's Day]]></title>
    <url>%2F2018%2F02%2F14%2FHappy-Valentine-s-Day%2F</url>
    <content type="text"><![CDATA[今天我不管世界，我只爱你，my girl 这是我们的第二个情人节，虽然不在彼此的身边，但是始终心存想念。还有就是：我寒假一定好好改造，开学的时候让狗子看到更好的自己。]]></content>
  </entry>
  <entry>
    <title><![CDATA[happy new year!]]></title>
    <url>%2F2017%2F12%2F31%2Fhappy-new-year%2F</url>
    <content type="text"><![CDATA[这一年，感谢有你，我的狗子。这是我俩在一起的第二个元旦，以后的每一个元旦也会在一起。就像那首歌唱到：我们要一直一直在一起就算与时间为敌就算与全世界背离 尽管发生过一些惹你不开心的事，但是也让我更加明白你对我的重要，好几次听到你说的一些话，眼泪自己就留下来了，控住不住自己啊，长这么大也只有我的狗子才让我流过泪。以前每天我会看看你的空间，看看你的留言，试图寻找你的过去，想了解你的喜好，想知道你爱吃什么，爱看什么，不过你后来把我屏蔽了，唉！现在的每一天，起床的第一件事就是看看手机有没有你的消息，看看你有没有登我的QQ，我一度曾经因为你好几天没登我的QQ而感到失落，因为我觉得你在登我QQ的时候，我觉得你在想我，甚至希望你多登几次，唉，我的狗子…… 今天是我俩在一起的第563天，时间过得好快好快，还记得当初见你的时候，会害羞会脸红，可是后来渐渐的熟悉，渐渐的了解，我不再害羞，你也不再害羞，当初你好像也会脸红，（别不承认啊），一路走来不易，未来的我一定更加努力，创建我们未来的小屋…… 以后的路我一直一直陪你走下去哟，死缠烂打也会，唉，谁让我那么爱你呢，大狗子，爱你么么。 想了好多话，一次写不完，以后的每天我会慢慢加的，爱你 么么！ 公元二零一捌年元月一日]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ty u menya odna]]></title>
    <url>%2F2017%2F11%2F12%2FTy-u-menya-odna%2F</url>
    <content type="text"><![CDATA[Ty u menya odna 当再次听到你说那句话时，不知咋的，突然很慌，眼泪止不住的流了出来，再也控制不住自己，未来虽然不可预知，但是人为可以创造，我相信我能行，你也能行，繁繁，请相信我也相信你自己。我俩会一直在一起，在一起。我们会有一个美好的未来。]]></content>
  </entry>
  <entry>
    <title><![CDATA[崛起]]></title>
    <url>%2F2017%2F10%2F12%2F%E5%B4%9B%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[狗子和我的重庆之旅]]></title>
    <url>%2F2017%2F10%2F06%2FChongqing%2F</url>
    <content type="text"><![CDATA[国庆终于到了，我和小可爱终于踏上了重庆之旅，算起来这是我和她第一次去很远的地方玩吧。由于车票(车票是硬座，对不起小乖,回去请她吃好吃的)的原因，只在重庆玩了三天,(但是到了重庆后发现三天时间已经足够把重庆好玩的地方都逛一遍了）。 坐了漫长的十几个小时的硬座后终于到了重庆，我俩第一站选择了距离火车站比较近的解放碑。解放碑的小吃很多，炸土豆、鱿鱼、豆腐、烤肉串密密麻麻的分布在解放碑商业圈的两边，走过一条长长的街道，就见到了解放碑的真面目。再往里面走，就没啥可逛的了,逛完解放碑我俩去了此次游玩相对好玩的地方之一（还有一个是洋人街）——洪崖洞，洪崖洞一共有十几层，每一层都分布着不同的东西,有古玩、有小吃、有玉器、有各种衣服、走出洪崖洞，外面的建筑依山而建，一条小瀑布从中飞跃而过，别有一番景致。我俩来来回回的在各层之间穿梭，逛累了来杯泰芒了。逛得差不多了我俩坐车去了磁器口，去磁器口之前期望蛮高的，到了那里后就傻眼了，恰逢大雨，人挤人路都不好走，吃了一顿重庆老火锅后就走了，走的时候选择了轻轨，那是第一次坐重庆的轻轨，毕生难忘，毫无秩序，几千人堵在轻轨的入口，没有工作人员维持秩序，全靠挤,老人和小孩去那种地要慎重，坐轻轨到达陈家桥站后，打个滴滴回了宾馆，去重庆的第一天就这样结束了。 第二天去了川美，川美的涂鸦很多，走进校门就可以看见一块坡地上有着各种彩色图案，还有一个很大的涂鸦馆，很有创意，校园里面就像一个大公园,适合拍照，很值得一去。 重大就在川美的旁边，我俩骑车过去，很遗憾的是重大不对外开放。然后我俩就骑车到了最近的轻轨大学城站，坐轻轨去了朝天门，现象中的朝天门是个大码头，气势宏伟，到了后才发现就那样，没什么特点，江面上停着几艘大轮船，准备坐船玩玩的，但是白天沿江两岸没什么景色，就改变计划，去了洋人街，洋人街的游乐设施挺多的，我俩租了一辆观光车沿着洋人街来回了开了几遍，然后去了游乐场,35元玩遍35个项目，实际上很多项目都玩不了，但是也不错了。和狗子第一次坐旋转木马、骑异形自行车、坐漂 流船（半道还被前面的船卡住了，多亏我机智，半路 下船）还有一些项目忘了名字。玩完这些项目已经快天黑了，我俩就坐车回了宾馆。这算是去重庆玩的最充实的一天吧。 本来规划的第三天去长江索道和山城步道，但是由于天气原因和距离原因，就放弃了去长江索道，而是去了山城步道，山城步道依山的走势而建，走了一 小会就腿脚发麻。一路走过,几乎全是情侣,哈哈哈, 我俩也虐了一次狗了。逛完山城步道已经中午了，狗子想吃火锅，由于火车是当天晚上的，解放碑距离火车站比较近，吃的又比较多，综合各种因素我俩就再次到了解放碑，找了一家火锅店，本来想吃份不辣的火锅，但是老板比较坑逼，说是没有三鲜的，就上了一份微辣的，然后我和狗子就一把鼻涕一把泪的吃完了这份重庆微辣老火锅，这次吃完火锅后，我几个 月内不想再吃这玩意,多亏我家狗子聪明,要了一碗热水，每夹一筷子菜要在碗里涮一下，这样才能吃老火锅实在是太辣了。 吃完火锅也差不多该走了，大概总结一下，重庆好玩的地真不多，玩了几天一张门票都没买。小吃比较多，就像路边摊那种的，遍地都是，主食可以选择火锅、重庆鸡公煲（在重庆几乎没看到鸡公煲）。出行公交轻轨都还行，滴滴比较便宜，赶时间可以叫滴滴。 此次旅途虽然有些瑕疵，但是很难忘，主要是和狗子在一块，带着她玩，带着她吃，而她呢还不忘给我省钱，有她真好，下次旅途再见。 最后附上小乖的图片镇楼。]]></content>
      <categories>
        <category>旅行</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[she is coming]]></title>
    <url>%2F2017%2F09%2F02%2Fshe-is-coming%2F</url>
    <content type="text"><![CDATA[Today is September second, you are with me again, I from the holiday to now has in the past forty-two days, I miss you my lovely, bright future in this semester.]]></content>
      <categories>
        <category>girl</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The weather in Pingquan]]></title>
    <url>%2F2017%2F08%2F01%2Fweather-in-Pingquan%2F</url>
    <content type="text"><![CDATA[我很想你，每天就记录下你那边的天气。 日 期 天 气 温 度 风 力 8月1日 多云/雷阵雨 31 ~ 22℃ 微风 8月2日 中雨 /暴雨 28 ~ 21℃ 微风 8月3日 阵雨/多云 21 ~ 30℃ 微风 8月4日 多云 33 ~ 21℃ 微风 8月5日 雷阵雨 32 ~ 19℃ 微风 8月6日 雷阵雨转多云 32 ~ 18℃ 微风 8月7日 多云 32 ~ 17℃ 微风 8月8日 雷阵雨 32 ~ 17℃ 微风 8月9日 中雨/雷阵雨 26 ~ 18℃ 微风 8月10日 雷阵雨/多云 19 ~ 30℃ 微风 8月11日 雷阵雨 19 ~ 32℃ 微风 8月12日 雷阵雨 /多云 29 ~ 18℃ 微风 8月13日 多云/雷阵雨 28 ~ 18℃ 微风 8月14日 雷阵雨/多云 28 ~ 17℃ 微风 8月15日 雷阵雨 29 ~ 17℃ 微风 8月16日 雷阵雨 28 ~ 16℃ 微风 8月17日 雷阵雨/多云 28 ~ 17℃ 微风 8月18日 雷阵雨/多云 29 ~ 17℃ 微风 8月19日 多云 29 ~ 15℃ 微风 8月20日 多云转阴 25 ~ 17℃ 微风 8月21日 多云 32 ~ 19℃ 微风 8月22日 雷阵雨/中雨 28 ~ 19℃ 微风]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android布局与组件]]></title>
    <url>%2F2017%2F07%2F26%2FAndroid%E5%B8%83%E5%B1%80%E4%B8%8E%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[六大布局Android的五大布局分别是LinearLayout–线性布局,FrameLayout–单帧(框架)布局, RelativeLayout–相对布局, AbsoluteLayout–绝对布局和TableLayout–表格布局，GridLayout–网格布局。 LinearLayout LinearLayout按照垂直或者水平的顺序依次排列子元素，每一个子元素都位于前一个元素之后。如果是垂直排列，那么将是一个N行单列的结构，每一行只会有一个元素，不论这个元素的宽度为多少；如果是水平排列，那么将是一个单行N列的结构。如果搭建两行两列的结构，通常的方式是先垂直排列两个元素，每一个元素里再包含一个LinearLayout进行水平排列。（嵌套） LinearLayout中的子元素属性android:layout_weight生效，它用于描述该子元素在剩余空间中占有的大小比例。加入一行只有一个文本框，那么它的默认值就为0，如果一行中有两个不等长的文本框，那么他们的android:layout_weight值分别为1和2，那么第一个文本框将占据剩余空间的三分之二，第二个文本框将占据剩余空间中的三分之一。 FrameLayout FrameLayout是五大布局中最简单的一个布局，在这个布局中，整个界面被当成一块空白备用区域，所有的子元素都不能被指定放置的位置，它们统统放于这块区域的左上角，并且后面的子元素直接覆盖在前面的子元素之上，将前面的子元素部分和全部遮挡。显示效果如下，第一个TextView被第二个TextView完全遮挡,第三个TextView遮挡了第二个TextView的部分位置。 AbsoluteLayout AbsoluteLayout是绝对位置布局。在此布局中的子元素的android:layout_x和android:layout_y属性将生效，用于描述该子元素的坐标位置。屏幕左上角为坐标原点（0,0），第一个0代表横坐标，向右移动此值增大，第二个0代表纵坐标，向下移动，此值增大。在此布局中的子元素可以相互重叠。在实际开发中，通常不采用此布局格式，因为它的界面代码过于刚性，以至于有可能不能很好的适配各种终端。 RelativeLayout RelativeLayout是Android五大布局结构中最灵活的一种布局,结构按照各子元素之间的位置关系完成布局。在此布局中的子元素里与位置相关的属性将生效。例如android：layout_below, android:layout_above等。子元素就通过这些属性和各自的ID配合指定位置关系。注意在指定位置关系时，引用的ID必须在引用之前，先被定义，否则将出现异常。 RelativeLayout里常用的位置属性如下: android:layout_toLeftOf —— 该组件位于引用组件的左方android:layout_toRightOf —— 该组件位于引用组件的右方android:layout_above —— 该组件位于引用组件的上方android:layout_below —— 该组件位于引用组件的下方android:layout_alignParentLeft —— 该组件是否对齐父组件的左端android:layout_alignParentRight —— 该组件是否齐其父组件的右端android:layout_alignParentTop —— 该组件是否对齐父组件的顶部android:layout_alignParentBottom —— 该组件是否对齐父组件的底部android:layout_centerInParent —— 该组件是否相对于父组件居中android:layout_centerHorizontal —— 该组件是否横向居中android:layout_centerVertical —— 该组件是否垂直居中 TableLayout TableLayout布局为表格布局，适用于N行N列的布局格式。一个TableLayout由许多TableRow组成，一个TableRow就代表TableLayout中的一行。TableRow是LinearLayout的子类，它的android:orientation属性值恒为horizontal，并且它的android:layout_width和android:layout_height属性值恒为MATCH_PARENT和WRAP_CONTENT。所以它的子元素都是横向排列，并且宽高一致的。这样的设计使得每个TableRow里的子元素都相当于表格中的单元格一样。在TableRow中，单元格可以为空，但是不能跨列。 GridLayout GridLayout是Android4.0增加的网格布局控件，与之前的TableLayout有些相似，它把整个容器划分为rows × columns个网格，每个网格可以放置一个组件。性能及功能都要比tablelayout好，比如GridLayout布局中的单元格可以跨越多行，而tablelayout则不行，此外，其渲染速度也比tablelayout要快。GridLayout提供了setRowCount(int)和setColumnCount(int)方法来控制该网格的行和列的数量。 布局之间的引用 在写布局文件时，经常会有一部分代码是重复的，为了提高代码的复用性和减少代码量，通常的做法是将相同的那一部分写入一个layout文件中让其它布局文件去调用，这时再调用的布局文件用到布局，在该布局里加入layout=”@layout/“被引用的布局文件名”。 四大组件Android四大组件分别为activity、service、content provider、broadcast receiver。 一、android四大组件详解 1、activity （1）一个Activity通常就是一个单独的窗口。 （2）Activity之间通过Intent进行通信。 （3）android应用中每一个Activity都必须要在AndroidManifest.xml配置文件中声明，否则系统将不识别也不执行该Activity。 2、service （1）service用于在后台完成用户指定的操作。service分为两种： （a）started（启动）：当应用程序组件（如activity）调用startService()方法启动服务时，服务处于started状态。 （b）bound（绑定）：当应用程序组件调用bindService()方法绑定到服务时，服务处于bound状态。 (2)startService()与bindService()区别： (a)started service（启动服务）是由其他组件调用startService()方法启动的，这导致服务的onStartCommand()方法被调用。当服务是started状态时，其生命周期与启动它的组件无关，并且可以在后台无限期运行，即使启动服务的组件已经被销毁。因此，服务需要在完成任务后调用stopSelf()方法停止，或者由其他组件调用stopService()方法停止。 (b)使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。 (3)开发人员需要在应用程序配置文件中声明全部的service，使用标签。 (4)Service通常位于后台运行，它一般不需要与用户交互，因此Service组件没有图形用户界面。Service组件需要继承Service基类。Service组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。 3、content provider （1）android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。 （2）只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处是统一数据访问方式。 （3）ContentProvider实现数据共享。ContentProvider用于保存和获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方式，因为android没有提供所有应用共同访问的公共存储区。 （4）开发人员不会直接使用ContentProvider类的对象，大多数是通过ContentResolver对象实现对ContentProvider的操作。 （5）ContentProvider使用URI来唯一标识其数据集，这里的URI以content://作为前缀，表示该数据由ContentProvider来管理。 4、broadcast receiver （1）你的应用可以使用它对外部事件进行过滤，只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力，例如闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 （2）广播接收者的注册有两种方法，分别是程序动态注册和AndroidManifest文件中进行静态注册。 （3）动态注册广播接收器特点是当用来注册的Activity关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器也是打开着的。也就是说哪怕app本身未启动，该app订阅的广播在触发时也会对它起作用。 二、android四大组件总结： （1）4大组件的注册 4大基本组件都需要注册才能使用，每个Activity、service、Content Provider都需要在AndroidManifest文件中进行配置。AndroidManifest文件中未进行声明的activity、服务以及内容提供者将不为系统所见，从而也就不可用。而broadcast receiver广播接收者的注册分静态注册（在AndroidManifest文件中进行配置）和通过代码动态创建并以调用Context.registerReceiver()的方式注册至系统。需要注意的是在AndroidManifest文件中进行配置的广播接收者会随系统的启动而一直处于活跃状态，只要接收到感兴趣的广播就会触发（即使程序未运行）。 （2）4大组件的激活 内容提供者的激活：当接收到ContentResolver发出的请求后，内容提供者被激活。而其它三种组件activity、服务和广播接收器被一种叫做intent的异步消息所激活。 （3）4大组件的关闭 内容提供者仅在响应ContentResolver提出请求的时候激活。而一个广播接收器仅在响应广播信息的时候激活。所以，没有必要去显式的关闭这些组件。Activity关闭：可以通过调用它的finish()方法来关闭一个activity。服务关闭：对于通过startService()方法启动的服务要调用Context.stopService()方法关闭服务，使用bindService()方法启动的服务要调用Contex.unbindService()方法关闭服务。 （4）android中的任务（activity栈） （a）任务其实就是activity的栈，它由一个或多个Activity组成，共同完成一个完整的用户体验。栈底的是启动整个任务的Activity，栈顶的是当前运行的用户可以交互的Activity，当一个activity启动另外一个的时候，新的activity就被压入栈，并成为当前运行的activity。而前一个activity仍保持在栈之中。当用户按下BACK键的时候，当前activity出栈，而前一个恢复为当前运行的activity。栈中保存的其实是对象，栈中的Activity永远不会重排，只会压入或弹出。 （b）任务中的所有activity是作为一个整体进行移动的。整个的任务（即activity栈）可以移到前台，或退至后台。 （c）Android系统是一个多任务(Multi-Task)的操作系统，可以在用手机听音乐的同时，也执行其他多个程序。每多执行一个应用程序，就会多耗费一些系统内存，当同时执行的程序过多，或是关闭的程序没有正确释放掉内存，系统就会觉得越来越慢，甚至不稳定。为了解决这个问题，Android引入了一个新的机制，即生命周期(Life Cycle)。 Android技能网址：https://blog.csdn.net/shenggaofei/article/details/52134357]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[July]]></title>
    <url>%2F2017%2F07%2F21%2Fjuly%2F</url>
    <content type="text"><![CDATA[You’re gone today. See you in September.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Forigin leadership]]></title>
    <url>%2F2017%2F07%2F17%2Fforigin%2F</url>
    <content type="text"><![CDATA[Seventeenth/July/2017In SHAANXI NORMAL UNIVERSITY My introduction as a leader My name is Lmf, I study in Philosphy ang Government management Achademy. I major in Administration management.I came from Cheng de,Hebei province,where the emperor avoid summer heat,called by people mountain restort.I hope you can have a visit. In the first grade, we learn the clsss named Management, we talk about the organization, for example, the campany . The strategy , the leader also will be discussed. I have learned about how to make strategy,how to inspire the employees and so on. Actually ,I didn’t learn very well though I work hard. Because I don’t think it easy to be a good leader, It is related to many things. Just like the equation that the leader’s behaviour depends on whether the followers support him(or her) and the suorrounding whether adapt to the leader. I have also studied the organizational behavior, the course introduced the personality and psychology as an employee, values、attitudes and job satisfaction of knowledge, is also described as a leader can take incentive measures to explain the relevant incentive theory, also introduced the related enterprises to success stories, these enterprises from the start of appeared in the process of growing a large number enterprises have everfount vitality and success. If I were a leader, I should have a deep analysis of my advantages and disadvantages, first of all my professional is related to management, I will choose my job according in the knowledge of I learned , relevant theory and practice of the study gave me some experience, let me understand the X theory of evil human nature view ,also learn the y theory the individual needs of view. As a leader, I can better understand the psychological and behavioral characteristics of their activities, take corresponding incentive measures to meet their needs, to achieve the goal of the organization, I am a firm target person and will take action to achieve the goal, just like the Path-goal theory, remove obstacles and indicate the direction for the members of the organization. As my mind clear, in the face of various problems and difficulties, I will be calm and take accurate measures , strong organizational skills, organizational members can collaborative behavior in the organization, the strategic of good accurate positioning, I can develop a reasonable short-term and long-term goals for the organization. I often read related books, and Dulake mentioned in his book that a good manager should have five main habits:１ make good use of time.２ pay attention to contribution.３ good at discovering other people’s strengths.４ distinguish between primary and secondary work.５ make effective decisions. At the same time I should correct my shortcomings, I think I am careless, sometimes lack of care for members of the organization, when assign the task that I didn’t fully take into account the characteristics of members of the organization, can not maximize the strengths of members of the organization. Hesitate in making decisions and not make the best use of time. Simply speaking, become a successful leader not only depends on my behaviour and the support of members in the organization, as well as the influence of environment in the promotion. I will pay attention to the influence of environment , and create a good organization environment to achieve the goal,that’s all my instruction.]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手机操作系统内核]]></title>
    <url>%2F2017%2F07%2F17%2F%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[对于Android系统是啥的问题，大家基本都有一些概念，毕竟目前大多数的智能手机都运行在这一操作系统之上，而提到Linux就要陌生很多，更别说Android基于Linux内核这句话了.这次我就来说说有关操作系统内核的一些普及版知识。 什么是操作系统内核？实际上这个问题的答案复杂难懂,所谓操作系统内核(Kernel)就是操作系统的核心底层软件结构，负责软件对硬件的访问，以及管理进程、内存、驱动程序以及支持文件系统等基础功能。或者说，完全可以顾名思义，它就是整个操作系统运行的基础,如果操作系统像一辆车,那内核就约等于发动机,它的性能和稳定性就是整个操作系统正常运行的关键。 当然深究起来以上的说法不是完全准确，只是一种通俗化的理解，毕竟要是完全吃透了就可以去从事内核开发，远不是这篇文章该做且能做到的事情。接下来，我们就来看看，常见的这些操作系统基于什么内核。 Windows NT内核：我们现在用的电脑绝大部分都是运行Windows操作系统的PC机，那么它们运行在什么内核上呢？它的学名叫Windows NT，是由微软自己开发的闭源内核，对位于高性能的计算机系统。最早发布于1993年，首次登陆用户个人电脑的版本便是大名鼎鼎的Windows2000，直到最新的Win10，都是基于此款令微软引以为傲的内核。 此外，我们知道在智能手机上，微软也在维护着Windows Phone系列操作系统，当然现在已经改名叫Windows 10 mobile，即便现在因为市场占有率实在太低而被戏称为1%。这个系列从windows phone 8（即WP8）开始也是基于Windows NT内核，而在此之前，则是运行在下一节要讲到的那个内核上。 内核Unix内核：那么iOS和现在Mac电脑上跑的Mac OS X是什么内核呢？它们其实基于同一款内核，学名叫Darwin，基于前苹果CEO史蒂夫·乔布斯创立的NEXT公司所开发的OpenStep，而OpenStep及其前身NextStep则是衍生于加州大学伯克利分校所发布的Berkeley Software Distribution即BSD，是Unix的一个重要分支。 而Unix则是目前看到的这群操作系统内核中最为古老的，诞生于1969年的贝尔实验室，由于历史原因，Unix一直处于一个半闭源的状态（理论闭源，但其他开发者还是能得到足够的代码），于是出现了一堆变种，它们大多没有完全遵守Unix的规范，被称为类Unix（即Unix-like）。 Linux内核：接下来是大名鼎鼎的Linux,最早是芬兰黑客Linus Torvalds于1991年推出。它属于类Unix家族中的一支,不过由于一直开源导致广泛传播,名气要比Unix大得多,有着众多的发行版，比如桌面上的Ubuntu，路由器上的OpenWRT（事实上路由器的系统基本都是基于Linux）,以及占据大部分智能手机份额的谷歌Android。 Linux之所以强大，首先是它对于硬件的强兼容性，几乎所有的平台都能跑Linux，而不像Windows NT那样过于倾心于X86平台（虽然近些年也能在ARM上跑了）；其二在于其坚持的开源免费思想，造就了以Lunix社区为核心的全球开发模式，由创始人带领的团队负责内核的维护更新，而全球的开发者为其进行稳定性的debug使其稳定，强大，还免费，自然受到了诸多青睐。除Android以外，以往出现过的三星Bada OS、Tizen OS，还有诺基亚曾经倾心的Meego，也都是基于Linux内核. 其他内核：由于历史的原因就忽略不计了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生日快乐]]></title>
    <url>%2F2017%2F07%2F12%2F%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[2017.7.12是李小繁童鞋的第N个生日，幸运的是这个生日我和她都在学校，然后就可以一起嗨皮了，希望她在新的一岁里，越来越漂亮，越来越可爱，虽然已经很漂亮很聪明了，哈哈哈。]]></content>
  </entry>
</search>
